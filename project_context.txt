Project Context From: /mnt/c/Users/Loic/Desktop/r/s2_moi/RO/TP2-simplex-tab-dual-grandM
Generated On: Mon May 26 05:38:53 WAT 2025
===============================================
Ignored Directory Patterns: .* node_modules vendor build dist target __pycache__ .next cache target venv storage
Ignored File Patterns: *.log *.jar *.pdf *.png *.jpg *.class *.sqlite *.csv project_context.txt package-lock.json yarn.lock composer.lock *.ico pnpm-lock.yaml
===============================================

//---> PATH: /mnt/c/Users/Loic/Desktop/r/s2_moi/RO/TP2-simplex-tab-dual-grandM/.gitignore

/__pycache__
/build
/dist
/stats.json
/grand_m.json// END OF FILE: .gitignore

//---> PATH: /mnt/c/Users/Loic/Desktop/r/s2_moi/RO/TP2-simplex-tab-dual-grandM/READEME.md

# Solveur de Programmation Linéaire Avancé

Bienvenue dans le Solveur de Programmation Linéaire Avancé. Ce projet universitaire est une application de bureau complète, conçue pour résoudre les problèmes de programmation linéaire (PL) en utilisant diverses méthodes. Il offre à la fois une interface en ligne de commande (CLI) interactive et une interface utilisateur graphique (GUI) moderne et riche en fonctionnalités pour une expérience utilisateur optimale.

<!-- Insérer ici une capture d'écran ou un GIF de l'application en action -->
<!-- Exemple : <p align="center"><img src="demo.gif" alt="Démo du Solveur Simplexe"></p> -->

## Fonctionnalités Clés

Ce solveur se distingue par un ensemble de fonctionnalités avancées :

*   **Interface Utilisateur Graphique (GUI) Moderne :**
    *   Développée avec **CustomTkinter** pour un design élégant et personnalisable (thèmes clair/sombre).
    *   Navigation intuitive avec barre de navigation, barre latérale et onglets.
    *   **Tableau de Bord (Dashboard)** : Visualisation des statistiques d'utilisation.
    *   **Définition de Problèmes Facilitée :** Champs de saisie dynamiques et validation.
    *   **Visualisations Interactives :**
        *   Région réalisable (pour problèmes à 2 variables) avec **Matplotlib**.
        *   Graphiques 3D (pour problèmes à 3 variables) avec **Plotly**.
        *   Animation du processus de résolution (concept).
    *   **Exportation de Rapports :** Génération de rapports PDF professionnels avec **ReportLab**.
    *   Gestion de Fichiers : Historique des problèmes, import/export (JSON, CSV, Excel - conceptuellement).
    *   Personnalisation : Thèmes de couleurs, taille de police (concept).
*   **Interface en Ligne de Commande (CLI) :**
    *   Menu interactif coloré (`colorama`, `tabulate`) pour une utilisation alternative.
    *   Fonctionnalités similaires à la GUI pour la définition et la résolution de problèmes.
*   **Méthodes de Résolution Implémentées :**
    *   **Simplexe Standard (Méthode Tabulaire)** : Pour les problèmes de maximisation avec contraintes `≤`.
    *   **Méthode du Grand M** : Pour gérer les contraintes d'égalité (`=`) et de supériorité (`≥`).
    *   **Méthode Duale** : Construction et résolution du problème dual, analyse primal-dual.
*   **Gestion des Problèmes :**
    *   Création interactive de nouveaux problèmes.
    *   Sauvegarde et chargement de problèmes depuis des fichiers JSON.
    *   Historique des problèmes résolus.
    *   Exemples prédéfinis pour une prise en main rapide.
*   **Lanceur Premium :**
    *   Un écran de démarrage (`main.py`) avec animations pour une première impression soignée avant le lancement de la GUI principale.
*   **Packaging :**
    *   Scripts de configuration pour **PyInstaller** (`SimplexSolver.spec`) et **cx_Freeze** (`setup.py`) pour créer des exécutables.

## Composants du Projet

Le projet est structuré en plusieurs modules Python, chacun ayant un rôle spécifique :

*   `main.py`: Lanceur "Premium" de l'application avec un écran de démarrage animé, qui ensuite lance l'interface graphique principale.
*   `gui.py`: Cœur de l'interface utilisateur graphique (GUI). Utilise CustomTkinter, Matplotlib, Plotly et ReportLab pour offrir une expérience riche et interactive.
*   `complete_example.py`: Fournit une interface en ligne de commande (CLI) complète et interactive pour définir, résoudre et gérer les problèmes de PL.
*   `tab_method.py`: Implémentation de la méthode du Simplexe standard (tabulaire).
*   `grand_M_method.py`: Implémentation de la méthode du Grand M.
*   `dual_method.py`: Implémentation de la construction du problème dual et de l'analyse primal-dual.
*   `enhanced_variables.py`: Fonctions améliorées pour la saisie des variables, l'affichage des tableaux simplexe en console (avec `tabulate`, `colorama`), et la gestion de l'historique des problèmes.
*   `variables.py`: Fonctions de base (potentiellement une version initiale) pour la saisie et l'affichage des variables et tableaux.
*   `SimplexSolver.spec`: Fichier de configuration pour PyInstaller, permettant de packager l'application en un exécutable.
*   `setup.py`: Script de configuration pour cx_Freeze, une autre option pour créer un exécutable.
*   `.gitignore`: Spécifie les fichiers et dossiers à ignorer par Git.
*   `icon.ico`: Icône utilisée pour l'application et l'exécutable.

## Technologies Utilisées

*   **Langage :** Python 3.x
*   **Interface Graphique (GUI) :**
    *   Tkinter (bibliothèque standard Python)
    *   CustomTkinter (pour un look moderne)
*   **Visualisation de Données :**
    *   Matplotlib (graphiques 2D)
    *   Plotly (graphiques 3D interactifs)
*   **Manipulation de Données :**
    *   NumPy (pour les calculs numériques, implicitement via Matplotlib/Plotly)
    *   Pandas (potentiellement pour la gestion de données tabulaires, importé dans `gui.py`)
*   **Interface Console (CLI) :**
    *   Colorama (texte coloré)
    *   Tabulate (affichage de tableaux en console)
*   **Exportation :**
    *   ReportLab (génération de PDF)
*   **Packaging :**
    *   PyInstaller
    *   cx_Freeze

## Installation et Utilisation

### Option 1 : Exécutable Pré-compilé (Windows)

Un exécutable pour Windows est disponible au téléchargement. Cela vous permet d'utiliser l'application sans avoir à installer Python ou les dépendances manuellement.

*   **Télécharger l'exécutable :** [SimplexSolver.exe via Google Drive](https://drive.google.com/file/d/1_pgSaU6TG14vFB8ZcEdVEToY079U3rLY/view?usp=sharing)
*   Après le téléchargement, vous pouvez simplement exécuter le fichier `SimplexSolver.exe`.

### Option 2 : Depuis le Code Source

1.  **Prérequis :**
    *   Python 3.8 ou supérieur.
    *   `pip` (gestionnaire de paquets Python).

2.  **Cloner le Dépôt (si applicable) ou Télécharger les Fichiers Source :**
    ```bash
    # Si c'est un dépôt Git
    git clone <url-du-depot>
    cd <nom-du-dossier-du-projet>
    ```

3.  **Créer un Environnement Virtuel (Recommandé) :**
    ```bash
    python -m venv venv
    # Sous Windows
    .\venv\Scripts\activate
    # Sous macOS/Linux
    source venv/bin/activate
    ```

4.  **Installer les Dépendances :**
    Les dépendances principales sont listées dans `SimplexSolver.spec` et `setup.py`. Vous pouvez les installer manuellement ou créer un fichier `requirements.txt`.
    ```bash
    pip install customtkinter matplotlib numpy colorama tabulate pandas plotly reportlab seaborn Pillow
    ```
    *(Note: `seaborn` et `Pillow` sont listés comme dépendances cachées ou pour des fonctionnalités spécifiques dans le `.spec`)*

### Lancement de l'Application (depuis le code source)

*   **Interface Graphique (GUI) :**
    Pour démarrer l'application avec son interface graphique moderne et son lanceur premium :
    ```bash
    python main.py
    ```

*   **Interface en Ligne de Commande (CLI) :**
    Pour utiliser la version console interactive :
    ```bash
    python complete_example.py
    ```
    Suivez les instructions affichées dans le terminal pour définir et résoudre votre problème.

## Création de l'Exécutable (depuis le code source)

Si vous souhaitez recompiler l'exécutable :

### Avec PyInstaller

Utilisez le fichier `.spec` fourni :

```bash
pyinstaller SimplexSolver.spec
```// END OF FILE: READEME.md

//---> PATH: /mnt/c/Users/Loic/Desktop/r/s2_moi/RO/TP2-simplex-tab-dual-grandM/SimplexSolver.spec

# SimplexSolver.spec
# -*- mode: python ; coding: utf-8 -*-
from PyInstaller.utils.hooks import collect_submodules

block_cipher = None

# Liste des modules à inclure
added_files = [
    ('tab_method.py', '.'),
    ('variables.py', '.'),
    ('grand_M_method.py', '.'),
    ('dual_method.py', '.'),
    ('enhanced_variables.py', '.'),
    ('gui.py', '.'),
    # Ajoutez d'autres fichiers nécessaires
]

a = Analysis(
    ['main.py'],
    pathex=[],
    binaries=[],
    datas=added_files,
    hiddenimports=[
        # Tkinter et CustomTkinter
        'tkinter',
        'tkinter.ttk',
        'tkinter.messagebox',
        'tkinter.filedialog',
        'tkinter.font',
        'customtkinter',

        # Matplotlib
        'matplotlib',
        'matplotlib.pyplot',
        'matplotlib.figure',
        'matplotlib.backends.backend_tkagg',
        'matplotlib.patches',
        'matplotlib.animation',
        
        # Plotly - IMPORTANT pour résoudre l'erreur
        'plotly',
        'plotly.graph_objects',
        'plotly.graph_objs',
        'plotly.graph_objs._scatter',
        'plotly.graph_objs._bar',
        'plotly.graph_objs._line',
        'plotly.express',
        'plotly.subplots',
        'plotly.offline',
        'plotly.io',
        'plotly.validators',
        'plotly.colors',
        
        # Data processing
        'numpy',
        'pandas',
        'seaborn',
        
        # System et utilitaires
        'json',
        'os',
        'sys',
        'io',
        'base64',
        'datetime',
        'threading',
        'copy',
        'math',
        'time',
        'random',
        'webbrowser',
        'typing',
        
        # Image processing
        'PIL',
        'PIL.Image',
        'PIL.ImageDraw',
        'PIL.ImageFont',
        
        # PDF generation
        'reportlab',
        'reportlab.lib',
        'reportlab.lib.colors',
        'reportlab.lib.pagesizes',
        'reportlab.platypus',
        'reportlab.lib.styles',
        'reportlab.lib.units',
        
        # Console formatting
        'colorama',
        'tabulate'
    ]+ collect_submodules('plotly'),
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[
        'pysqlite2',
        'MySQLdb', 
        'psycopg2'
    ],
    collect_all=['plotly'],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.zipfiles,
    a.datas,
    [],
    name='SimplexSolver',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,  # False pour cacher la console
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon='icon.ico' 
)// END OF FILE: SimplexSolver.spec

//---> PATH: /mnt/c/Users/Loic/Desktop/r/s2_moi/RO/TP2-simplex-tab-dual-grandM/__init__.py

from . import variables
from . import tab_method// END OF FILE: __init__.py

//---> PATH: /mnt/c/Users/Loic/Desktop/r/s2_moi/RO/TP2-simplex-tab-dual-grandM/complete_example.py

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exemple complet d'utilisation des méthodes de programmation linéaire
Inclut: Simplexe Standard, Grand M, Dual, et système d'enregistrement
"""

import sys
import os
from enhanced_variables import interactive_problem_builder, VariableManager, enhanced_display_simplex_tableau
from tab_method import SimplexMethodTab
from grand_M_method import GrandMMethod
from dual_method import DualMethod
from colorama import init, Fore, Style

init()

class LinearProgrammingSolver:
    def __init__(self):
        self.variable_manager = VariableManager()
        self.current_problem = None
        self.current_method = None
    
    def main_menu(self):
        """Menu principal de l'application"""
        while True:
            print(f"\n{Fore.MAGENTA}{'='*80}")
            print("🔬 SOLVEUR DE PROGRAMMATION LINÉAIRE")
            print(f"{'='*80}{Style.RESET_ALL}")
            
            options = {
                "1": "📝 Créer un nouveau problème",
                "2": "📂 Charger un problème existant", 
                "3": "🔍 Résoudre le problème actuel",
                "4": "🔄 Analyser Primal-Dual",
                "5": "📊 Historique des problèmes",
                "6": "💾 Sauvegarder le problème actuel",
                "7": "❌ Quitter"
            }
            
            for key, desc in options.items():
                print(f"  {key}. {desc}")
            
            if self.current_problem:
                method = self.current_problem.get("method_type", "Inconnu")
                vars_count = self.current_problem.get("nombres_variables_base", 0)
                constraints_count = self.current_problem.get("nb_equations", 0)
                print(f"\n📌 Problème actuel: {method} ({vars_count} vars, {constraints_count} contraintes)")
            
            choice = input(f"\n{Fore.YELLOW}Votre choix: {Style.RESET_ALL}")
            
            if choice == "1":
                self.create_new_problem()
            elif choice == "2":
                self.load_problem()
            elif choice == "3":
                self.solve_current_problem()
            elif choice == "4":
                self.dual_analysis()
            elif choice == "5":
                self.show_history()
            elif choice == "6":
                self.save_current_problem()
            elif choice == "7":
                print("👋 Au revoir!")
                break
            else:
                print(f"{Fore.RED}❌ Choix invalide{Style.RESET_ALL}")
    
    def create_new_problem(self):
        """Crée un nouveau problème"""
        print(f"\n{Fore.CYAN}📝 CRÉATION D'UN NOUVEAU PROBLÈME{Style.RESET_ALL}")
        
        try:
            variables, method = interactive_problem_builder()
            if variables:
                self.current_problem = variables
                self.current_method = method
                
                # Sauvegarde automatique dans l'historique
                index = self.variable_manager.save_problem(variables, method)
                print(f"✅ Problème créé et sauvegardé (index: {index})")
                
                # Affichage du problème
                enhanced_display_simplex_tableau(variables, 0, method)
            else:
                print(f"{Fore.RED}❌ Création annulée{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}❌ Erreur lors de la création: {e}{Style.RESET_ALL}")
    
    def load_problem(self):
        """Charge un problème existant"""
        print(f"\n{Fore.CYAN}📂 CHARGEMENT D'UN PROBLÈME{Style.RESET_ALL}")
        
        print("Options de chargement:")
        print("1. Depuis un fichier")
        print("2. Depuis l'historique")
        print("3. Exemples prédéfinis")
        
        choice = input("Votre choix (1-3): ")
        
        if choice == "1":
            filename = input("Nom du fichier: ")
            variables = self.variable_manager.load_from_file(filename)
            if variables:
                self.current_problem = variables
                self.current_method = variables.get("method_type", "Chargé")
                enhanced_display_simplex_tableau(variables, 0, self.current_method)
        
        elif choice == "2":
            self.variable_manager.list_history()
            if self.variable_manager.history:
                try:
                    index = int(input("Index du problème à charger: "))
                    variables = self.variable_manager.get_problem(index)
                    if variables:
                        self.current_problem = variables
                        self.current_method = self.variable_manager.history[index]["method"]
                        print(f"✅ Problème {index} chargé")
                        enhanced_display_simplex_tableau(variables, 0, self.current_method)
                    else:
                        print(f"{Fore.RED}❌ Index invalide{Style.RESET_ALL}")
                except ValueError:
                    print(f"{Fore.RED}❌ Index invalide{Style.RESET_ALL}")
        
        elif choice == "3":
            self.load_predefined_examples()
        else:
            print(f"{Fore.RED}❌ Choix invalide{Style.RESET_ALL}")
    
    def load_predefined_examples(self):
        """Charge des exemples prédéfinis"""
        examples = {
            "1": {
                "name": "Exemple Standard (3x₁ + 5x₂)",
                "variables": {
                    "tab_optimisation": [0, 3, 5],
                    "nombres_variables_base": 2,
                    "equations": {
                        "equation_1": [4, 1, 0],
                        "equation_2": [12, 0, 2],
                        "equation_3": [18, 3, 2],
                    },
                    "nb_equations": 3,
                    "method_type": "Simplexe Standard"
                }
            },
            "2": {
                "name": "Exemple Grand M (avec contrainte d'égalité)",
                "variables": {
                    "tab_optimisation": [0, 3, 5],
                    "nombres_variables_base": 2,
                    "equations": {
                        "equation_1": [4, 1, 0],
                        "equation_2": [12, 0, 2],
                        "equation_3": [18, 3, 2],
                    },
                    "nb_equations": 3,
                    "constraints_info": ["<=", "<=", "="],
                    "method_type": "Grand M"
                }
            },
            "3": {
                "name": "Problème de minimisation",
                "variables": {
                    "tab_optimisation": [0, -7, -6, -5],  # Min devient Max avec -
                    "nombres_variables_base": 3,
                    "equations": {
                        "equation_1": [18, 3, 8, 6],
                        "equation_2": [15, 1, 2, 6],
                    },
                    "nb_equations": 2,
                    "constraints_info": ["=", "="],
                    "method_type": "Grand M",
                    "objective_type": "min"
                }
            }
        }
        
        print("\nExemples disponibles:")
        for key, example in examples.items():
            print(f"  {key}. {example['name']}")
        
        choice = input("Choisir un exemple (1-3): ")
        if choice in examples:
            self.current_problem = examples[choice]["variables"]
            self.current_method = examples[choice]["variables"]["method_type"]
            print(f"✅ {examples[choice]['name']} chargé")
            enhanced_display_simplex_tableau(self.current_problem, 0, self.current_method)
        else:
            print(f"{Fore.RED}❌ Exemple invalide{Style.RESET_ALL}")
    
    def solve_current_problem(self):
        """Résout le problème actuel"""
        if not self.current_problem:
            print(f"{Fore.RED}❌ Aucun problème à résoudre. Créez ou chargez un problème d'abord.{Style.RESET_ALL}")
            return
        
        print(f"\n{Fore.CYAN}🔍 RÉSOLUTION DU PROBLÈME{Style.RESET_ALL}")
        
        # Déterminer la méthode appropriée
        constraints_info = self.current_problem.get("constraints_info", [])
        has_equality = "=" in constraints_info
        has_greater_equal = ">=" in constraints_info
        
        print("Méthodes de résolution disponibles:")
        methods = ["1. Simplexe Standard"]
        
        if has_equality or has_greater_equal:
            methods.extend(["2. Grand M", "3. Deux Phases (non implémenté)"])
        
        for method in methods:
            print(f"  {method}")
        
        # Suggestion automatique
        if has_equality or has_greater_equal:
            suggested = "2"
            print(f"\n💡 Méthode suggérée: Grand M (contraintes d'égalité ou ≥ détectées)")
        else:
            suggested = "1"
            print(f"\n💡 Méthode suggérée: Simplexe Standard")
        
        choice = input(f"Votre choix [{suggested}]: ") or suggested
        
        try:
            if choice == "1":
                self.solve_with_standard_simplex()
            elif choice == "2":
                self.solve_with_grand_m()
            elif choice == "3":
                print(f"{Fore.YELLOW}⚠️ Méthode des deux phases non encore implémentée{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}❌ Choix invalide{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.RED}❌ Erreur lors de la résolution: {e}{Style.RESET_ALL}")
    
    def solve_with_standard_simplex(self):
        """Résout avec la méthode du simplexe standard"""
        print(f"\n{Fore.GREEN}🚀 Résolution par Simplexe Standard{Style.RESET_ALL}")
        
        # Copie pour éviter de modifier l'original
        import copy
        problem_copy = copy.deepcopy(self.current_problem)
        
        solver = SimplexMethodTab(problem_copy)
        solver.run()
    
    def solve_with_grand_m(self):
        """Résout avec la méthode du Grand M"""
        print(f"\n{Fore.GREEN}🚀 Résolution par Grand M{Style.RESET_ALL}")
        
        # Copie pour éviter de modifier l'original
        import copy
        problem_copy = copy.deepcopy(self.current_problem)
        
        solver = GrandMMethod(problem_copy)
        solver.run()
    
    def dual_analysis(self):
        """Effectue une analyse primal-dual"""
        if not self.current_problem:
            print(f"{Fore.RED}❌ Aucun problème pour l'analyse duale.{Style.RESET_ALL}")
            return
        
        print(f"\n{Fore.CYAN}🔄 ANALYSE PRIMAL-DUAL{Style.RESET_ALL}")
        
        # Vérifier si le problème est compatible avec l'analyse duale
        constraints_info = self.current_problem.get("constraints_info", [])
        if any(c in [">=", "="] for c in constraints_info):
            print(f"{Fore.YELLOW}⚠️ Le problème contient des contraintes ≥ ou =.")
            print("L'analyse duale sera effectuée après conversion en forme standard.{Style.RESET_ALL}")
        
        try:
            import copy
            problem_copy = copy.deepcopy(self.current_problem)
            
            dual_analyzer = DualMethod(problem_copy)
            dual_analyzer.run_complete_analysis()
        except Exception as e:
            print(f"{Fore.RED}❌ Erreur lors de l'analyse duale: {e}{Style.RESET_ALL}")
    
    def show_history(self):
        """Affiche l'historique des problèmes"""
        print(f"\n{Fore.CYAN}📊 HISTORIQUE DES PROBLÈMES{Style.RESET_ALL}")
        self.variable_manager.list_history()
    
    def save_current_problem(self):
        """Sauvegarde le problème actuel"""
        if not self.current_problem:
            print(f"{Fore.RED}❌ Aucun problème à sauvegarder.{Style.RESET_ALL}")
            return
        
        filename = input("Nom du fichier de sauvegarde: ")
        if filename:
            self.variable_manager.save_to_file({
                "timestamp": "Manual save",
                "method": self.current_method or "Inconnu",
                "variables": self.current_problem,
                "metadata": {
                    "nb_variables": self.current_problem.get("nombres_variables_base", 0),
                    "nb_contraintes": self.current_problem.get("nb_equations", 0),
                    "constraints_types": self.current_problem.get("constraints_info", [])
                }
            }, filename)

def demo_complete():
    """Démonstration complète des fonctionnalités"""
    print(f"{Fore.MAGENTA}{'='*80}")
    print("🎯 DÉMONSTRATION COMPLÈTE DU SOLVEUR")
    print(f"{'='*80}{Style.RESET_ALL}")
    
    # Exemple 1: Problème standard
    print(f"\n{Fore.CYAN}📋 EXEMPLE 1: Problème Standard{Style.RESET_ALL}")
    variables_std = {
        "tab_optimisation": [0, 3, 5],
        "nombres_variables_base": 2,
        "equations": {
            "equation_1": [4, 1, 0],
            "equation_2": [12, 0, 2],
            "equation_3": [18, 3, 2],
        },
        "nb_equations": 3,
        "method_type": "Simplexe Standard"
    }
    
    print("Max Z = 3x₁ + 5x₂")
    print("  x₁ ≤ 4")
    print("  2x₂ ≤ 12")  
    print("  3x₁ + 2x₂ ≤ 18")
    
    solver_std = SimplexMethodTab(variables_std)
    solver_std.run()
    
    # Exemple 2: Grand M
    print(f"\n{Fore.CYAN}📋 EXEMPLE 2: Méthode du Grand M{Style.RESET_ALL}")
    variables_gm = {
        "tab_optimisation": [0, 3, 5],
        "nombres_variables_base": 2,
        "equations": {
            "equation_1": [4, 1, 0],
            "equation_2": [12, 0, 2],
            "equation_3": [18, 3, 2],
        },
        "nb_equations": 3,
        "constraints_info": ["<=", "<=", "="],
        "method_type": "Grand M"
    }
    
    print("Max Z = 3x₁ + 5x₂")
    print("  x₁ ≤ 4")
    print("  2x₂ ≤ 12")
    print("  3x₁ + 2x₂ = 18")
    
    solver_gm = GrandMMethod(variables_gm)
    solver_gm.run()
    
    # Exemple 3: Analyse duale
    print(f"\n{Fore.CYAN}📋 EXEMPLE 3: Analyse Primal-Dual{Style.RESET_ALL}")
    dual_analyzer = DualMethod(variables_std)
    dual_analyzer.run_complete_analysis()

if __name__ == "__main__":
    print("Choisir le mode d'exécution:")
    print("1. Interface interactive")
    print("2. Démonstration complète")
    
    choice = input("Votre choix (1-2): ")
    
    if choice == "1":
        app = LinearProgrammingSolver()
        app.main_menu()
    elif choice == "2":
        demo_complete()
    else:
        print("Choix invalide, lancement de l'interface interactive par défaut...")
        app = LinearProgrammingSolver()
        app.main_menu()// END OF FILE: complete_example.py

//---> PATH: /mnt/c/Users/Loic/Desktop/r/s2_moi/RO/TP2-simplex-tab-dual-grandM/dual_method.py

from variables import display_simplex_tableau
from tab_method import SimplexMethodTab
import copy

class DualMethod:
    def __init__(self, primal_variables: dict):
        self.primal_variables = primal_variables
        self.dual_variables = None
        self.construct_dual()
        
    def construct_dual(self):
        """Construit le problème dual à partir du problème primal"""
        print(f"\n{'='*60}")
        print("CONSTRUCTION DU PROBLÈME DUAL")
        print(f"{'='*60}")
        
        # Extraire les données du problème primal
        primal_c = self.primal_variables["tab_optimisation"][1:]  # Coefficients fonction objectif
        primal_equations = list(self.primal_variables["equations"].values())
        primal_b = [eq[0] for eq in primal_equations]  # Membres de droite
        
        # Matrice des contraintes A (sans les membres de droite)
        primal_A = []
        for eq in primal_equations:
            primal_A.append(eq[1:self.primal_variables["nombres_variables_base"] + 1])
        
        self.display_primal_problem(primal_c, primal_A, primal_b)
        
        # Construction du dual
        # Nombre de variables duales = nombre de contraintes primales
        dual_n = len(primal_equations)
        
        # Coefficients de la fonction objectif du dual = membres de droite du primal
        dual_c = primal_b.copy()
        
        # Contraintes du dual: A^T * y >= c (du primal)
        dual_equations = {}
        dual_b = primal_c.copy()
        
        # Transposition de la matrice A
        dual_A = []
        for j in range(len(primal_A[0])):  # Pour chaque variable primale
            dual_constraint = []
            dual_constraint.append(dual_b[j])  # Membre de droite
            for i in range(len(primal_A)):     # Pour chaque contrainte primale
                dual_constraint.append(primal_A[i][j])
            dual_A.append(dual_constraint)
            dual_equations[f"equation_{j+1}"] = dual_constraint
        
        # Le dual est un problème de minimisation, on le convertit en maximisation
        # Min f(y) = -Max(-f(y))
        dual_tab_optimisation = [0] + [-c for c in dual_c]
        
        self.dual_variables = {
            "tab_optimisation": dual_tab_optimisation,
            "nombres_variables_base": dual_n,
            "equations": dual_equations,
            "nb_equations": len(dual_equations),
            "constraints_info": [">="] * len(dual_equations)  # Toutes les contraintes sont >=
        }
        
        self.display_dual_problem(dual_c, dual_A, dual_b)
        
    def display_primal_problem(self, c, A, b):
        """Affiche le problème primal"""
        print("\nPROBLÈME PRIMAL:")
        print("Max Z =", end="")
        for i, coeff in enumerate(c):
            if i == 0:
                print(f" {coeff}x{i+1}", end="")
            else:
                print(f" + {coeff}x{i+1}" if coeff >= 0 else f" - {abs(coeff)}x{i+1}", end="")
        print()
        
        print("Sujet à:")
        for i, (constraint, rhs) in enumerate(zip(A, b)):
            print("  ", end="")
            for j, coeff in enumerate(constraint):
                if j == 0:
                    print(f"{coeff}x{j+1}", end="")
                else:
                    print(f" + {coeff}x{j+1}" if coeff >= 0 else f" - {abs(coeff)}x{j+1}", end="")
            print(f" ≤ {rhs}")
        
        print("  x_i ≥ 0 pour tout i")
    
    def display_dual_problem(self, c, A, b):
        """Affiche le problème dual"""
        print("\nPROBLÈME DUAL:")
        print("Min W =", end="")
        for i, coeff in enumerate(c):
            if i == 0:
                print(f" {coeff}y{i+1}", end="")
            else:
                print(f" + {coeff}y{i+1}" if coeff >= 0 else f" - {abs(coeff)}y{i+1}", end="")
        print()
        
        print("Sujet à:")
        for i, constraint in enumerate(A):
            print("  ", end="")
            rhs = constraint[0]
            coeffs = constraint[1:]
            for j, coeff in enumerate(coeffs):
                if j == 0:
                    print(f"{coeff}y{j+1}", end="")
                else:
                    print(f" + {coeff}y{j+1}" if coeff >= 0 else f" - {abs(coeff)}y{j+1}", end="")
            print(f" ≥ {rhs}")
        
        print("  y_i ≥ 0 pour tout i")
        
        print("\nÉquivalent en maximisation:")
        print("Max W' = -W =", end="")
        for i, coeff in enumerate(c):
            if i == 0:
                print(f" {-coeff}y{i+1}", end="")
            else:
                print(f" + {-coeff}y{i+1}" if -coeff >= 0 else f" - {abs(-coeff)}y{i+1}", end="")
        print()
    
    def solve_dual(self):
        """Résout le problème dual"""
        print(f"\n{'='*60}")
        print("RÉSOLUTION DU PROBLÈME DUAL")
        print(f"{'='*60}")
        
        # Pour résoudre les contraintes >=, on les convertit en <=
        # a1*y1 + a2*y2 + ... >= b devient -a1*y1 - a2*y2 - ... <= -b
        converted_equations = {}
        for key, equation in self.dual_variables["equations"].items():
            converted_eq = [-equation[0]]  # -b
            converted_eq.extend([-x for x in equation[1:]])  # -coefficients
            converted_equations[key] = converted_eq
        
        dual_for_simplex = {
            "tab_optimisation": self.dual_variables["tab_optimisation"],
            "nombres_variables_base": self.dual_variables["nombres_variables_base"],
            "equations": converted_equations,
            "nb_equations": self.dual_variables["nb_equations"]
        }
        
        print("Résolution du dual par la méthode du simplexe:")
        simplex_dual = SimplexMethodTab(dual_for_simplex)
        simplex_dual.run()
        
        return dual_for_simplex
    
    def solve_primal(self):
        """Résout le problème primal pour comparaison"""
        print(f"\n{'='*60}")
        print("RÉSOLUTION DU PROBLÈME PRIMAL")
        print(f"{'='*60}")
        
        print("Résolution du primal par la méthode du simplexe:")
        simplex_primal = SimplexMethodTab(copy.deepcopy(self.primal_variables))
        simplex_primal.run()
        
        return self.primal_variables
    
    def compare_solutions(self, primal_result, dual_result):
        """Compare les solutions primale et duale"""
        print(f"\n{'='*60}")
        print("COMPARAISON DES SOLUTIONS")
        print(f"{'='*60}")
        
        primal_z = primal_result["tab_optimisation"][0]
        dual_w = -dual_result["tab_optimisation"][0]  # Rappel: on a maximisé -W
        
        print(f"Valeur optimale du primal (Z): {primal_z:.6f}")
        print(f"Valeur optimale du dual (W): {dual_w:.6f}")
        print(f"Différence |Z - W|: {abs(primal_z - dual_w):.10f}")
        
        if abs(primal_z - dual_w) < 1e-6:
            print("✅ Théorème de dualité forte vérifié: Z* = W*")
        else:
            print("❌ Problème dans les calculs - les valeurs devraient être égales")
        
        # Extraction des solutions
        print("\nSOLUTION PRIMALE:")
        primal_equations = list(primal_result["equations"].values())
        for j in range(1, self.primal_variables["nombres_variables_base"] + 1):
            value = 0
            for i, eq in enumerate(primal_equations):
                if j < len(eq) and abs(eq[j] - 1.0) < 1e-10:
                    others_zero = all(abs(other_eq[j]) < 1e-10 for k, other_eq in enumerate(primal_equations) if k != i)
                    if others_zero:
                        value = eq[0]
            print(f"  x{j} = {value:.6f}")
        
        print("\nSOLUTION DUALE:")
        dual_equations = list(dual_result["equations"].values())
        for j in range(1, self.dual_variables["nombres_variables_base"] + 1):
            value = 0
            for i, eq in enumerate(dual_equations):
                if j < len(eq) and abs(eq[j] - 1.0) < 1e-10:
                    others_zero = all(abs(other_eq[j]) < 1e-10 for k, other_eq in enumerate(dual_equations) if k != i)
                    if others_zero:
                        value = eq[0]
            print(f"  y{j} = {value:.6f}")
    
    def run_complete_analysis(self):
        """Exécute l'analyse complète primal-dual"""
        print(f"\n{'='*80}")
        print("ANALYSE COMPLÈTE PRIMAL-DUAL")
        print(f"{'='*80}")
        
        # Résolution des deux problèmes
        primal_result = self.solve_primal()
        dual_result = self.solve_dual()
        
        # Comparaison
        self.compare_solutions(primal_result, dual_result)
        
        # Analyse économique
        self.economic_interpretation()
    
    def economic_interpretation(self):
        """Fournit une interprétation économique"""
        print(f"\n{'='*60}")
        print("INTERPRÉTATION ÉCONOMIQUE")
        print(f"{'='*60}")
        
        print("PROBLÈME PRIMAL:")
        print("- Variables x_j: niveaux d'activité")
        print("- Coefficients c_j: profits unitaires")
        print("- Contraintes: limitations de ressources")
        print("- Objectif: maximiser le profit total")
        
        print("\nPROBLÈME DUAL:")
        print("- Variables y_i: prix implicites (valeurs marginales) des ressources")
        print("- Coefficients b_i: quantités de ressources disponibles") 
        print("- Contraintes: la valeur des ressources utilisées ≥ profit de l'activité")
        print("- Objectif: minimiser la valeur totale des ressources")
        
        print("\nTHÉORÈME DE DUALITÉ:")
        print("- Si les deux problèmes ont une solution optimale, alors Z* = W*")
        print("- Les prix optimaux du dual indiquent la valeur marginale de chaque ressource")
        print("- Une ressource avec prix dual nul n'est pas entièrement utilisée")


# Exemple d'utilisation
if __name__ == "__main__":
    # Exemple classique
    # Max Z = 3x1 + 5x2
    # x1 ≤ 4
    # 2x2 ≤ 12
    # 3x1 + 2x2 ≤ 18
    # x1, x2 ≥ 0
    
    variables_primal = {
        "tab_optimisation": [0, 3, 5],
        "nombres_variables_base": 2,
        "equations": {
            "equation_1": [4, 1, 0],
            "equation_2": [12, 0, 2],
            "equation_3": [18, 3, 2],
        },
        "nb_equations": 3
    }
    
    dual_analyzer = DualMethod(variables_primal)
    dual_analyzer.run_complete_analysis()// END OF FILE: dual_method.py

//---> PATH: /mnt/c/Users/Loic/Desktop/r/s2_moi/RO/TP2-simplex-tab-dual-grandM/enhanced_variables.py

from tabulate import tabulate
from colorama import init, Fore, Style
import json
import os
from datetime import datetime

# Initialiser colorama
init()

class VariableManager:
    def __init__(self):
        self.history = []
        self.current_problem = None
        
    def save_problem(self, variables, method_name, filename=None):
        """Sauvegarde un problème avec métadonnées"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        problem_data = {
            "timestamp": timestamp,
            "method": method_name,
            "variables": variables,
            "metadata": {
                "nb_variables": variables.get("nombres_variables_base", 0),
                "nb_contraintes": variables.get("nb_equations", 0),
                "constraints_types": variables.get("constraints_info", [])
            }
        }
        
        self.history.append(problem_data)
        
        if filename:
            self.save_to_file(problem_data, filename)
        
        return len(self.history) - 1  # Retourne l'index
    
    def save_to_file(self, problem_data, filename):
        """Sauvegarde dans un fichier JSON"""
        if not filename.endswith('.json'):
            filename += '.json'
        
        try:
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(problem_data, f, indent=2, ensure_ascii=False)
            print(f"✅ Problème sauvegardé dans {filename}")
        except Exception as e:
            print(f"❌ Erreur lors de la sauvegarde: {e}")
    
    def load_from_file(self, filename):
        """Charge un problème depuis un fichier JSON"""
        if not filename.endswith('.json'):
            filename += '.json'
        
        try:
            with open(filename, 'r', encoding='utf-8') as f:
                problem_data = json.load(f)
            
            self.history.append(problem_data)
            print(f"✅ Problème chargé depuis {filename}")
            return problem_data["variables"]
        except Exception as e:
            print(f"❌ Erreur lors du chargement: {e}")
            return None
    
    def list_history(self):
        """Affiche l'historique des problèmes"""
        if not self.history:
            print("Aucun problème dans l'historique.")
            return
        
        print(f"\n{Fore.CYAN}{'='*60}")
        print("HISTORIQUE DES PROBLÈMES")
        print(f"{'='*60}{Style.RESET_ALL}")
        
        for i, problem in enumerate(self.history):
            print(f"\n{Fore.YELLOW}[{i}] {problem['method']}{Style.RESET_ALL}")
            print(f"  📅 {problem['timestamp']}")
            print(f"  📊 {problem['metadata']['nb_variables']} variables, {problem['metadata']['nb_contraintes']} contraintes")
            if problem['metadata']['constraints_types']:
                print(f"  🔗 Contraintes: {', '.join(problem['metadata']['constraints_types'])}")
    
    def get_problem(self, index):
        """Récupère un problème par son index"""
        if 0 <= index < len(self.history):
            return self.history[index]["variables"]
        return None

def enhanced_tab_var(nombres_variables_base: int, nb_equations: int, method_type="Simplexe Standard") -> dict:
    """Version améliorée de tab_var avec plus d'options"""
    print(f"{Fore.CYAN}{'='*70}")
    print(f"CONFIGURATION - {method_type.upper()}")
    print(f"{'='*70}{Style.RESET_ALL}")
    print(f"📈 {nombres_variables_base} variables de décision")
    print(f"📋 {nb_equations} contraintes")
    
    # Fonction objectif
    tab_optimisation = [0]
    print(f"\n{Fore.GREEN}[1] FONCTION OBJECTIF{Style.RESET_ALL}")
    
    # Choix min/max
    obj_type = input("Type d'optimisation (max/min) [max]: ").lower() or "max"
    
    print(f"Fonction à {obj_type}imiser: Z = ", end="")
    for i in range(nombres_variables_base):
        if i > 0:
            print(" + ", end="")
        print(f"c{i+1}x{i+1}", end="")
    print()
    
    coefficients = []
    for i in range(nombres_variables_base):
        while True:
            try:
                coeff = float(input(f"c{i+1} = {Fore.YELLOW}"))
                print(Style.RESET_ALL, end="")
                coefficients.append(coeff)
                tab_optimisation.append(coeff)
                break
            except ValueError:
                print(f"{Fore.RED}Veuillez entrer un nombre valide.{Style.RESET_ALL}")
    
    # Contraintes
    print(f"\n{Fore.GREEN}[2] CONTRAINTES{Style.RESET_ALL}")
    equations = {}
    constraints_info = []
    
    # Options pour les contraintes
    if method_type in ["Grand M", "Deux Phases"]:
        print("Types de contraintes disponibles: ≤ (<=), ≥ (>=), = (=)")
    
    data_table = []
    headers = ["Contrainte"] + [f"x{i+1}" for i in range(nombres_variables_base)] + ["Type", "b"]
    
    for j in range(nb_equations):
        print(f"\n{Fore.BLUE}Contrainte {j+1}:{Style.RESET_ALL}")
        
        equation = []
        # Membre de droite
        while True:
            try:
                b_value = float(input(f"Membre de droite b{j+1} = {Fore.YELLOW}"))
                print(Style.RESET_ALL, end="")
                equation.append(b_value)
                break
            except ValueError:
                print(f"{Fore.RED}Veuillez entrer un nombre valide.{Style.RESET_ALL}")
        
        # Coefficients
        coeffs = []
        for k in range(nombres_variables_base):
            while True:
                try:
                    coeff = float(input(f"a{j+1}{k+1} (coeff. de x{k+1}) = {Fore.YELLOW}"))
                    print(Style.RESET_ALL, end="")
                    coeffs.append(coeff)
                    equation.append(coeff)
                    break
                except ValueError:
                    print(f"{Fore.RED}Veuillez entrer un nombre valide.{Style.RESET_ALL}")
        
        # Type de contrainte
        if method_type in ["Grand M", "Deux Phases"]:
            while True:
                constraint_type = input("Type de contrainte (<=, >=, =) [<=]: ") or "<="
                if constraint_type in ["<=", ">=", "="]:
                    constraints_info.append(constraint_type)
                    break
                print(f"{Fore.RED}Type invalide. Utilisez <=, >= ou ={Style.RESET_ALL}")
        else:
            constraint_type = "<="
            constraints_info.append(constraint_type)
        
        equations[f"equation_{j+1}"] = equation
        data_table.append([f"C{j+1}"] + coeffs + [constraint_type, b_value])
    
    # Récapitulatif
    print(f"\n{Fore.CYAN}{'='*70}")
    print("RÉCAPITULATIF DU PROBLÈME")
    print(f"{'='*70}{Style.RESET_ALL}")
    
    obj_row = [f"{obj_type.title()}imiser Z"] + coefficients + ["", tab_optimisation[0]]
    
    print(f"\n{tabulate([obj_row] + data_table, headers=headers, tablefmt='grid', floatfmt='.3f')}")
    
    # Confirmation
    while True:
        confirm = input(f"\n{Fore.YELLOW}Confirmer ce problème ? (o/n) [o]: {Style.RESET_ALL}") or "o"
        if confirm.lower() in ['o', 'oui', 'y', 'yes']:
            break
        elif confirm.lower() in ['n', 'non', 'no']:
            print("❌ Annulation...")
            return None
        
    # Ajustement pour minimisation
    if obj_type == "min":
        tab_optimisation = [tab_optimisation[0]] + [-x for x in tab_optimisation[1:]]
    
    variables = {
        "tab_optimisation": tab_optimisation,
        "nombres_variables_base": nombres_variables_base,
        "equations": equations,
        "nb_equations": nb_equations,
        "constraints_info": constraints_info,
        "objective_type": obj_type,
        "method_type": method_type
    }
    
    # Proposition de sauvegarde
    save = input(f"{Fore.GREEN}Sauvegarder ce problème ? (o/n) [n]: {Style.RESET_ALL}") or "n"
    if save.lower() in ['o', 'oui', 'y', 'yes']:
        filename = input("Nom du fichier [auto]: ") or f"probleme_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        manager = VariableManager()
        manager.save_to_file({
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "method": method_type,
            "variables": variables,
            "metadata": {
                "nb_variables": nombres_variables_base,
                "nb_contraintes": nb_equations,
                "constraints_types": constraints_info
            }
        }, filename)
    
    return variables

def enhanced_display_simplex_tableau(variables, iteration=0, method_name="Simplexe"):
    """Version améliorée de l'affichage du tableau"""
    equations = variables["equations"]
    tab_optimisation = variables["tab_optimisation"]
    
    print(f"\n{Fore.CYAN}{'='*70}")
    print(f"TABLEAU {method_name.upper()} - ITÉRATION {iteration}")
    print(f"{'='*70}{Style.RESET_ALL}")
    
    # Information sur le type d'objectif
    obj_type = variables.get("objective_type", "max")
    print(f"🎯 Objectif: {obj_type}imisation")
    
    # Calcul du nombre de variables totales
    nb_vars_base = variables["nombres_variables_base"]
    total_vars = len(tab_optimisation) - 1
    nb_slack_artificial = total_vars - nb_vars_base
    
    # En-têtes dynamiques
    headers = ["Base", "Cst"]
    headers.extend([f"x{i+1}" for i in range(nb_vars_base)])
    
    # Variables d'écart et artificielles
    if nb_slack_artificial > 0:
        constraints_info = variables.get("constraints_info", [])
        var_index = nb_vars_base + 1
        
        for i, constraint_type in enumerate(constraints_info):
            if constraint_type == "<=":
                headers.append(f"s{i+1}")
                var_index += 1
            elif constraint_type == ">=":
                headers.append(f"s{i+1}")
                headers.append(f"a{i+1}")
                var_index += 2
            elif constraint_type == "=":
                headers.append(f"a{i+1}")
                var_index += 1
    
    # Construction des lignes
    rows = []
    
    # Ligne de la fonction objectif
    obj_row = [f"Z ({obj_type})"] + tab_optimisation
    # Compléter avec des zéros si nécessaire
    while len(obj_row) < len(headers):
        obj_row.append(0)
    rows.append(obj_row)
    
    # Lignes des contraintes
    base_vars = []
    for i, (key, eq) in enumerate(equations.items()):
        # Déterminer la variable de base pour cette ligne
        base_var = f"s{i+1}"  # Par défaut
        
        # Chercher la variable de base réelle
        for j in range(1, len(eq)):
            if abs(eq[j] - 1.0) < 1e-10:
                # Vérifier que c'est bien une variable de base
                others_zero = True
                for other_key, other_eq in equations.items():
                    if other_key != key and j < len(other_eq) and abs(other_eq[j]) > 1e-10:
                        others_zero = False
                        break
                if others_zero:
                    if j <= nb_vars_base:
                        base_var = f"x{j}"
                    else:
                        # Variable d'écart ou artificielle
                        base_var = headers[j+1] if j+1 < len(headers) else f"var{j}"
                    break
        
        base_vars.append(base_var)
        row = [base_var] + eq
        # Compléter avec des zéros si nécessaire
        while len(row) < len(headers):
            row.append(0)
        rows.append(row)
    
    # Affichage du tableau
    print(f"\n{tabulate(rows, headers=headers, tablefmt='grid', floatfmt='.3f')}")
    
    # Informations supplémentaires
    if iteration > 0:
        z_value = tab_optimisation[0]
        print(f"\n📊 Valeur actuelle de Z: {z_value:.6f}")
        
        # Variables de base actuelles
        print(f"🔧 Variables de base: {', '.join(base_vars)}")
    
    return {"base_variables": base_vars, "z_value": tab_optimisation[0]}

def interactive_problem_builder():
    """Interface interactive pour construire un problème"""
    print(f"{Fore.MAGENTA}{'='*70}")
    print("CONSTRUCTEUR INTERACTIF DE PROBLÈMES")
    print(f"{'='*70}{Style.RESET_ALL}")
    
    print("🚀 Méthodes disponibles:")
    methods = {
        "1": ("Simplexe Standard", "tab_var"),
        "2": ("Grand M", "enhanced_tab_var"),
        "3": ("Deux Phases", "enhanced_tab_var"),
        "4": ("Charger depuis fichier", "load_file")
    }
    
    for key, (name, _) in methods.items():
        print(f"  {key}. {name}")
    
    while True:
        choice = input(f"\n{Fore.YELLOW}Choisissez une méthode (1-4): {Style.RESET_ALL}")
        if choice in methods:
            method_name, method_type = methods[choice]
            break
        print(f"{Fore.RED}Choix invalide{Style.RESET_ALL}")
    
    if method_type == "load_file":
        filename = input("Nom du fichier à charger: ")
        manager = VariableManager()
        variables = manager.load_from_file(filename)
        return variables, "Fichier chargé"
    
    # Saisie des dimensions
    while True:
        try:
            nb_vars = int(input(f"\n{Fore.CYAN}Nombre de variables de décision: {Style.RESET_ALL}"))
            if nb_vars > 0:
                break
            print(f"{Fore.RED}Le nombre doit être positif{Style.RESET_ALL}")
        except ValueError:
            print(f"{Fore.RED}Veuillez entrer un nombre entier{Style.RESET_ALL}")
    
    while True:
        try:
            nb_constraints = int(input(f"{Fore.CYAN}Nombre de contraintes: {Style.RESET_ALL}"))
            if nb_constraints > 0:
                break
            print(f"{Fore.RED}Le nombre doit être positif{Style.RESET_ALL}")
        except ValueError:
            print(f"{Fore.RED}Veuillez entrer un nombre entier{Style.RESET_ALL}")
    
    # Construction du problème
    variables = enhanced_tab_var(nb_vars, nb_constraints, method_name)
    
    return variables, method_name

# Mise à jour de la fonction display_simplex_tableau existante
def display_simplex_tableau(variables, iteration=0):
    """Wrapper pour maintenir la compatibilité"""
    method_name = variables.get("method_type", "Simplexe")
    return enhanced_display_simplex_tableau(variables, iteration, method_name)

if __name__ == "__main__":
    # Test du système amélioré
    print("Test du système d'enregistrement amélioré")
    
    # Interface interactive
    variables, method = interactive_problem_builder()
    
    if variables:
        print("\n✅ Problème construit avec succès!")
        display_simplex_tableau(variables, 0)// END OF FILE: enhanced_variables.py

//---> PATH: /mnt/c/Users/Loic/Desktop/r/s2_moi/RO/TP2-simplex-tab-dual-grandM/grand_M_method.py

from variables import display_simplex_tableau
import copy
from fractions import Fraction

class GrandMMethod:
    def __init__(self, variables: dict):
        self.variables = variables
        self.n = variables["nombres_variables_base"]
        self.M = 1000  # Valeur de M (très grande)
        self.artificial_vars = []
        self.iteration = 0
        
    def run(self):
        """Exécute la méthode du Grand M"""
        print(f"\n{'='*60}")
        print("MÉTHODE DU GRAND M")
        print(f"{'='*60}")
        
        # Ajout des variables d'écart et artificielles
        self.add_slack_and_artificial_variables()
        
        # Modification de la fonction objectif
        self.modify_objective_function()
        
        # Rendre le tableau propre
        self.make_tableau_proper()
        
        # Affichage du tableau initial
        print("\nTableau initial après introduction des variables artificielles:")
        display_simplex_tableau(self.variables, 0)
        
        # Itérations du simplexe
        while self.can_iterate():
            self.iteration += 1
            print(f"\n{'='*20} Itération {self.iteration} {'='*20}")
            
            col = self.find_pivot_column()
            if col == -1:
                break
                
            pivot_row = self.find_pivot_row(col)
            if pivot_row == -1:
                print("Solution illimitée!")
                return
                
            print(f"Colonne pivot : {col}")
            print(f"Ligne pivot : {pivot_row}")
            
            self.pivot_operation(pivot_row, col)
            display_simplex_tableau(self.variables, self.iteration)
        
        self.analyze_final_solution()
    
    def add_slack_and_artificial_variables(self):
        """Ajoute les variables d'écart et artificielles selon le type de contrainte"""
        constraints_info = self.variables.get("constraints_info", [])
        equations = list(self.variables["equations"].values())
        
        # Si pas d'info sur les contraintes, on assume toutes ≤
        if not constraints_info:
            constraints_info = ["<="] * len(equations)
        
        slack_count = 0
        artificial_count = 0
        
        # Modification de la fonction objectif pour inclure les nouvelles variables
        original_vars = len(self.variables["tab_optimisation"])
        
        for i, constraint_type in enumerate(constraints_info):
            if constraint_type == "<=":
                # Variable d'écart
                self.variables["tab_optimisation"].append(0)
                slack_count += 1
            elif constraint_type == ">=":
                # Variable d'écart (négative) + variable artificielle
                self.variables["tab_optimisation"].append(0)  # Variable d'écart
                self.variables["tab_optimisation"].append(-self.M)  # Variable artificielle
                self.artificial_vars.append(original_vars + slack_count + artificial_count + 1)
                slack_count += 1
                artificial_count += 1
            elif constraint_type == "=":
                # Variable artificielle seulement
                self.variables["tab_optimisation"].append(-self.M)
                self.artificial_vars.append(original_vars + slack_count + artificial_count)
                artificial_count += 1
        
        # Modification des équations
        total_new_vars = slack_count + artificial_count
        for i, constraint_type in enumerate(constraints_info):
            current_length = len(equations[i])
            target_length = original_vars + total_new_vars
            
            # Ajouter des zéros pour toutes les nouvelles variables
            while len(equations[i]) < target_length:
                equations[i].append(0)
            
            # Placer les coefficients appropriés
            var_index = original_vars - 1  # -1 car on compte à partir de 0
            
            if constraint_type == "<=":
                var_index += 1
                equations[i][var_index] = 1  # Variable d'écart
            elif constraint_type == ">=":
                var_index += 1
                equations[i][var_index] = -1  # Variable d'écart (négative)
                var_index += 1
                equations[i][var_index] = 1   # Variable artificielle
            elif constraint_type == "=":
                var_index += 1
                equations[i][var_index] = 1   # Variable artificielle
        
        # Mise à jour des équations dans variables
        for k, equation in enumerate(equations):
            self.variables["equations"][list(self.variables["equations"].keys())[k]] = equation
    
    def modify_objective_function(self):
        """Modifie la fonction objectif en ajoutant -M pour les variables artificielles"""
        # La fonction objectif est déjà modifiée dans add_slack_and_artificial_variables
        # On inverse le signe pour la maximisation
        self.variables["tab_optimisation"] = [-x for x in self.variables["tab_optimisation"]]
    
    def make_tableau_proper(self):
        """Rend le tableau propre en éliminant les variables artificielles de la fonction objectif"""
        equations = list(self.variables["equations"].values())
        tab_optimisation = self.variables["tab_optimisation"].copy()
        
        for var_index in self.artificial_vars:
            # Trouver la ligne où cette variable artificielle est de base
            for i, equation in enumerate(equations):
                if var_index < len(equation) and equation[var_index] == 1:
                    # Éliminer cette variable de la fonction objectif
                    coeff = tab_optimisation[var_index]
                    for j in range(len(tab_optimisation)):
                        if j < len(equation):
                            tab_optimisation[j] -= coeff * equation[j]
                    break
        
        self.variables["tab_optimisation"] = tab_optimisation
    
    def find_pivot_column(self):
        """Trouve la colonne pivot (coefficient le plus négatif)"""
        min_val = min(self.variables["tab_optimisation"][1:])
        if min_val >= 0:
            return -1
        return self.variables["tab_optimisation"][1:].index(min_val) + 1
    
    def find_pivot_row(self, col):
        """Trouve la ligne pivot selon la règle du minimum des rapports"""
        equations = list(self.variables["equations"].values())
        min_ratio = float('inf')
        pivot_row = -1
        
        for i, equation in enumerate(equations):
            if col < len(equation) and equation[col] > 0:
                ratio = equation[0] / equation[col]
                if ratio < min_ratio:
                    min_ratio = ratio
                    pivot_row = i
        
        return pivot_row
    
    def pivot_operation(self, pivot_row, pivot_col):
        """Effectue l'opération de pivotage"""
        equations = list(self.variables["equations"].values())
        tab_optimisation = self.variables["tab_optimisation"].copy()
        
        # Normaliser la ligne pivot
        pivot_element = equations[pivot_row][pivot_col]
        equations[pivot_row] = [x / pivot_element for x in equations[pivot_row]]
        
        # Éliminer la variable pivot des autres lignes
        for i in range(len(equations)):
            if i != pivot_row and pivot_col < len(equations[i]):
                factor = equations[i][pivot_col]
                for j in range(len(equations[i])):
                    equations[i][j] -= factor * equations[pivot_row][j]
        
        # Éliminer de la fonction objectif
        factor = tab_optimisation[pivot_col]
        for j in range(len(tab_optimisation)):
            if j < len(equations[pivot_row]):
                tab_optimisation[j] -= factor * equations[pivot_row][j]
        
        # Mise à jour
        self.variables["tab_optimisation"] = tab_optimisation
        for k, equation in enumerate(equations):
            self.variables["equations"][list(self.variables["equations"].keys())[k]] = equation
    
    def can_iterate(self):
        """Vérifie s'il faut continuer les itérations"""
        return any(x < -1e-10 for x in self.variables["tab_optimisation"][1:])
    
    def analyze_final_solution(self):
        """Analyse la solution finale"""
        print(f"\n{'='*60}")
        print("ANALYSE DE LA SOLUTION FINALE")
        print(f"{'='*60}")
        
        # Vérifier si les variables artificielles sont nulles
        artificial_in_solution = False
        equations = list(self.variables["equations"].values())
        
        for var_index in self.artificial_vars:
            # Chercher si cette variable artificielle est en base avec valeur non nulle
            for i, equation in enumerate(equations):
                if var_index < len(equation):
                    # Vérifier si c'est une variable de base
                    is_basic = abs(equation[var_index] - 1.0) < 1e-10
                    others_zero = all(abs(eq[var_index]) < 1e-10 for j, eq in enumerate(equations) if j != i)
                    
                    if is_basic and others_zero and abs(equation[0]) > 1e-10:
                        artificial_in_solution = True
                        print(f"⚠️  Variable artificielle x{var_index+1} = {equation[0]:.6f}")
        
        if artificial_in_solution:
            print("\n❌ PROBLÈME NON RÉALISABLE")
            print("Au moins une variable artificielle est non nulle dans la solution optimale.")
        else:
            print("\n✅ SOLUTION OPTIMALE TROUVÉE")
            z_opt = self.variables["tab_optimisation"][0]
            print(f"Valeur optimale: Z = {z_opt:.6f}")
            
            # Extraction de la solution
            var_values = [0] * self.variables["nombres_variables_base"]
            for j in range(1, self.variables["nombres_variables_base"] + 1):
                for i, eq in enumerate(equations):
                    if j < len(eq) and abs(eq[j] - 1.0) < 1e-10:
                        # Vérifier que c'est bien une variable de base
                        others_zero = all(abs(other_eq[j]) < 1e-10 for k, other_eq in enumerate(equations) if k != i)
                        if others_zero:
                            var_values[j-1] = eq[0]
            
            print("\nVariables de décision:")
            for i, val in enumerate(var_values):
                print(f"  x{i+1} = {val:.6f}")


# Exemple d'utilisation
if __name__ == "__main__":
    # Exemple du cours: 
    # Max Z = 3x1 + 5x2
    # x1 ≤ 4
    # 2x2 ≤ 12  
    # 3x1 + 2x2 = 18
    # x1, x2 ≥ 0
    
    variables_grand_m = {
        "tab_optimisation": [0, 3, 5],  # [constante, coeff_x1, coeff_x2]
        "nombres_variables_base": 2,
        "equations": {
            "equation_1": [4, 1, 0],    # x1 ≤ 4
            "equation_2": [12, 0, 2],   # 2x2 ≤ 12
            "equation_3": [18, 3, 2],   # 3x1 + 2x2 = 18
        },
        "nb_equations": 3,
        "constraints_info": ["<=", "<=", "="]  # Types de contraintes
    }
    
    print("Résolution par la méthode du Grand M:")
    grand_m = GrandMMethod(variables_grand_m)
    grand_m.run()// END OF FILE: grand_M_method.py

//---> PATH: /mnt/c/Users/Loic/Desktop/r/s2_moi/RO/TP2-simplex-tab-dual-grandM/gui.py

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Interface Graphique Ultra-Moderne pour le Solveur de Programmation Linéaire
Utilise CustomTkinter pour un design professionnel et moderne
"""

import customtkinter as ctk
import tkinter as tk
from tkinter import messagebox, filedialog
import matplotlib.pyplot as plt
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
import matplotlib.patches as patches
from matplotlib.animation import FuncAnimation
import numpy as np
import json
import os
from datetime import datetime
import threading
import sys
from PIL import Image, ImageDraw, ImageFont
import pandas as pd
from typing import Dict, List, Tuple, Optional
import seaborn as sns
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import webbrowser
from reportlab.lib import colors
from reportlab.lib.pagesizes import letter, A4
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, PageBreak, Image as RLImage
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
import io
import base64

# Configuration de CustomTkinter
ctk.set_appearance_mode("dark")  # Modes: "System" (standard), "Dark", "Light"
ctk.set_default_color_theme("blue")  # Themes: "blue" (standard), "green", "dark-blue"

# Import des modules existants
try:
    from tab_method import SimplexMethodTab
    from grand_M_method import GrandMMethod  
    from dual_method import DualMethod
    from enhanced_variables import VariableManager
    from variables import display_simplex_tableau
except ImportError as e:
    print(f"Erreur d'import: {e}")
    print("Assurez-vous que tous les modules sont dans le même dossier")

class ModernTheme:
    """Thème moderne avec support du mode sombre/clair"""
    
    def __init__(self):
        self.dark_mode = True
        self.update_colors()
    
    def update_colors(self):
        if self.dark_mode:
            # Mode sombre
            self.bg_primary = "#1a1a1a"
            self.bg_secondary = "#2b2b2b"
            self.bg_tertiary = "#3c3c3c"
            self.fg_primary = "#ffffff"
            self.fg_secondary = "#cccccc"
            self.fg_tertiary = "#999999"
            self.accent = "#3b82f6"
            self.success = "#10b981"
            self.warning = "#f59e0b"
            self.error = "#ef4444"
            self.border = "#4a4a4a"
        else:
            # Mode clair
            self.bg_primary = "#ffffff"
            self.bg_secondary = "#f3f4f6"
            self.bg_tertiary = "#e5e7eb"
            self.fg_primary = "#1f2937"
            self.fg_secondary = "#4b5563"
            self.fg_tertiary = "#6b7280"
            self.accent = "#3b82f6"
            self.success = "#10b981"
            self.warning = "#f59e0b"
            self.error = "#ef4444"
            self.border = "#d1d5db"
    
    def toggle(self):
        self.dark_mode = not self.dark_mode
        self.update_colors()
        ctk.set_appearance_mode("dark" if self.dark_mode else "light")

class AnimatedButton(ctk.CTkButton):
    """Bouton avec animations au survol"""
    
    def __init__(self, master, **kwargs):
        super().__init__(master, **kwargs)
        self.bind("<Enter>", self.on_enter)
        self.bind("<Leave>", self.on_leave)
        self.original_color = kwargs.get("fg_color", self._fg_color)
    
    def on_enter(self, event):
        self.configure(cursor="hand2")
        # Animation de couleur au survol
        if hasattr(self, '_fg_color'):
            self.configure(fg_color=self.original_color)
    
    def on_leave(self, event):
        self.configure(cursor="")

class ToolTip:
    """Classe pour afficher des tooltips"""
    
    def __init__(self, widget, text):
        self.widget = widget
        self.text = text
        self.tooltip = None
        self.widget.bind("<Enter>", self.on_enter)
        self.widget.bind("<Leave>", self.on_leave)
    
    def on_enter(self, event):
        self.show_tooltip()
    
    def on_leave(self, event):
        self.hide_tooltip()
    
    def show_tooltip(self):
        if self.tooltip or not self.text:
            return
        
        x, y, _, _ = self.widget.bbox("insert")
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 25
        
        self.tooltip = tk.Toplevel(self.widget)
        self.tooltip.wm_overrideredirect(True)
        self.tooltip.wm_geometry(f"+{x}+{y}")
        
        label = ctk.CTkLabel(self.tooltip, text=self.text, 
                            fg_color=("#333333", "#f0f0f0"),
                            corner_radius=6,
                            padx=10, pady=5)
        label.pack()
    
    def hide_tooltip(self):
        if self.tooltip:
            self.tooltip.destroy()
            self.tooltip = None

class SimplexGUI:
    """Interface graphique principale améliorée pour le solveur de programmation linéaire"""
    
    def __init__(self, root):
        self.root = root
        self.theme = ModernTheme()
        self.setup_window()
        self.variable_manager = VariableManager()
        self.current_problem = None
        self.solving_animation = None
        self.auto_save_enabled = True
        self.history_visualizations = []
        
        # Variables pour l'interface
        self.problem_vars = []
        self.constraint_vars = []
        self.constraint_types = []
        
        # Statistiques
        self.stats = {
            'problems_solved': 0,
            'total_iterations': 0,
            'avg_solving_time': 0,
            'methods_used': {'Simplexe': 0, 'Grand M': 0, 'Dual': 0}
        }
        
        self.create_main_interface()
        self.setup_keyboard_shortcuts()
        self.load_stats()
        
    def setup_window(self):
        """Configuration initiale de la fenêtre"""
        self.root.title("Solveur de Programmation Linéaire")
        self.root.geometry("1400x900")
        
        # Centrer la fenêtre
        self.root.update_idletasks()
        width = 1400
        height = 900
        x = (self.root.winfo_screenwidth() // 2) - (width // 2)
        y = (self.root.winfo_screenheight() // 2) - (height // 2)
        self.root.geometry(f"{width}x{height}+{x}+{y}")
        
        # Configuration de la grille
        self.root.grid_rowconfigure(0, weight=1)
        self.root.grid_columnconfigure(0, weight=1)
        
        # Icône personnalisée
        try:
            self.root.iconbitmap('icon.ico')
        except:
            pass
    
    def setup_keyboard_shortcuts(self):
        """Configure les raccourcis clavier"""
        self.root.bind('<Control-n>', lambda e: self.new_problem())
        self.root.bind('<Control-o>', lambda e: self.load_problem())
        self.root.bind('<Control-s>', lambda e: self.save_problem())
        self.root.bind('<Control-q>', lambda e: self.on_closing())
        self.root.bind('<F5>', lambda e: self.solve_standard())
        self.root.bind('<F6>', lambda e: self.solve_grand_m())
        self.root.bind('<F7>', lambda e: self.solve_dual())
        self.root.bind('<F11>', lambda e: self.toggle_fullscreen())
        self.root.bind('<Control-d>', lambda e: self.theme.toggle())
    
    def toggle_fullscreen(self):
        """Bascule en mode plein écran"""
        state = not self.root.attributes("-fullscreen")
        self.root.attributes("-fullscreen", state)
        
    def create_main_interface(self):
        """Crée l'interface principale moderne"""
        # Container principal
        self.main_container = ctk.CTkFrame(self.root, corner_radius=0)
        self.main_container.grid(row=0, column=0, sticky="nsew")
        self.main_container.grid_rowconfigure(1, weight=1)
        self.main_container.grid_columnconfigure(0, weight=1)
        
        # Barre de navigation supérieure
        self.create_navbar()
        
        # Zone principale avec sidebar
        self.content_frame = ctk.CTkFrame(self.main_container, corner_radius=0)
        self.content_frame.grid(row=1, column=0, sticky="nsew", padx=0, pady=0)
        self.content_frame.grid_rowconfigure(0, weight=1)
        self.content_frame.grid_columnconfigure(1, weight=1)
        
        # Sidebar
        self.create_sidebar()
        
        # Zone de contenu principal
        self.main_content = ctk.CTkFrame(self.content_frame)
        self.main_content.grid(row=0, column=1, sticky="nsew", padx=10, pady=10)
        self.main_content.grid_rowconfigure(0, weight=1)
        self.main_content.grid_columnconfigure(0, weight=1)
        
        # Tabview moderne
        self.create_modern_tabs()
        
        # Barre de statut
        self.create_status_bar()
        
    def create_navbar(self):
        """Crée une barre de navigation moderne"""
        self.navbar = ctk.CTkFrame(self.main_container, height=60, corner_radius=0)
        self.navbar.grid(row=0, column=0, sticky="ew", padx=0, pady=0)
        self.navbar.grid_columnconfigure(1, weight=1)
        
        # Logo et titre
        title_frame = ctk.CTkFrame(self.navbar, fg_color="transparent")
        title_frame.grid(row=0, column=0, padx=20, pady=10)
        
        title_label = ctk.CTkLabel(
            title_frame, 
            text="🚀 Solveur Simplexe Premium",
            font=ctk.CTkFont(size=24, weight="bold")
        )
        title_label.pack(side="left")
        
        # Boutons de navigation rapide
        nav_buttons_frame = ctk.CTkFrame(self.navbar, fg_color="transparent")
        nav_buttons_frame.grid(row=0, column=1, padx=20, pady=10)
        
        # Boutons avec icônes
        nav_buttons = [
            ("🏠 Dashboard", self.show_dashboard),
            ("📊 Résoudre", self.focus_solve_tab),
            ("📈 Visualiser", self.show_visualization),
            ("📚 Historique", self.show_history),
        ]
        
        for text, command in nav_buttons:
            btn = AnimatedButton(
                nav_buttons_frame,
                text=text,
                command=command,
                width=120,
                height=35,
                corner_radius=8
            )
            btn.pack(side="left", padx=5)
        
        # Boutons d'actions à droite
        actions_frame = ctk.CTkFrame(self.navbar, fg_color="transparent")
        actions_frame.grid(row=0, column=2, padx=20, pady=10)
        
        # Mode sombre/clair
        self.theme_switch = ctk.CTkSwitch(
            actions_frame,
            text="🌙",
            command=self.toggle_theme,
            width=50
        )
        self.theme_switch.pack(side="left", padx=10)
        ToolTip(self.theme_switch, "Basculer le thème")
        
        # Paramètres
        settings_btn = AnimatedButton(
            actions_frame,
            text="⚙️",
            command=self.show_settings,
            width=40,
            height=35,
            corner_radius=8
        )
        settings_btn.pack(side="left", padx=5)
        ToolTip(settings_btn, "Paramètres")
        
    def create_sidebar(self):
        """Crée une sidebar moderne"""
        self.sidebar = ctk.CTkFrame(self.content_frame, width=200, corner_radius=0)
        self.sidebar.grid(row=0, column=0, sticky="nsw", padx=(10, 0), pady=10)
        self.sidebar.grid_propagate(False)
        
        # Titre de la sidebar
        sidebar_title = ctk.CTkLabel(
            self.sidebar,
            text="Actions Rapides",
            font=ctk.CTkFont(size=16, weight="bold")
        )
        sidebar_title.pack(pady=(20, 10))
        
        # Séparateur
        separator = ctk.CTkFrame(self.sidebar, height=2)
        separator.pack(fill="x", padx=20, pady=10)
        
        # Boutons de la sidebar
        sidebar_buttons = [
            ("📝 Nouveau Problème", self.new_problem, "Ctrl+N"),
            ("📂 Charger", self.load_problem, "Ctrl+O"),
            ("💾 Sauvegarder", self.save_problem, "Ctrl+S"),
            ("🎯 Exemples", self.load_examples, None),
            ("📊 Comparer Méthodes", self.compare_methods, None),
            ("📈 Statistiques", self.show_statistics, None),
            ("🎨 Personnaliser", self.customize_interface, None),
            ("📤 Exporter PDF", self.export_to_pdf, None),
            ("❓ Aide", self.show_help, "F1"),
        ]
        
        for text, command, shortcut in sidebar_buttons:
            btn_frame = ctk.CTkFrame(self.sidebar, fg_color="transparent")
            btn_frame.pack(fill="x", padx=10, pady=5)
            
            btn = AnimatedButton(
                btn_frame,
                text=text,
                command=command,
                anchor="w",
                corner_radius=8,
                height=40
            )
            btn.pack(fill="x")
            
            if shortcut:
                shortcut_label = ctk.CTkLabel(
                    btn_frame,
                    text=shortcut,
                    font=ctk.CTkFont(size=10),
                    text_color="gray"
                )
                shortcut_label.place(relx=0.95, rely=0.5, anchor="e")
        
        # Zone d'information
        self.create_info_zone()
        
    def create_info_zone(self):
        """Crée une zone d'information dans la sidebar"""
        info_frame = ctk.CTkFrame(self.sidebar, corner_radius=10)
        info_frame.pack(fill="x", padx=10, pady=20, side="bottom")
        
        info_title = ctk.CTkLabel(
            info_frame,
            text="📊 Statistiques",
            font=ctk.CTkFont(size=14, weight="bold")
        )
        info_title.pack(pady=(10, 5))
        
        self.stats_label = ctk.CTkLabel(
            info_frame,
            text=f"Problèmes résolus: {self.stats['problems_solved']}\n"
                 f"Temps moyen: {self.stats['avg_solving_time']:.2f}s",
            font=ctk.CTkFont(size=12)
        )
        self.stats_label.pack(pady=(5, 10))
        
    def create_modern_tabs(self):
        """Crée des onglets modernes avec CustomTkinter"""
        self.tabview = ctk.CTkTabview(self.main_content, corner_radius=10)
        self.tabview.pack(fill="both", expand=True)
        
        # Création des onglets
        self.tabview.add("📝 Définition")
        self.tabview.add("🔍 Résolution") 
        self.tabview.add("📊 Résultats")
        self.tabview.add("📈 Visualisation")
        self.tabview.add("💾 Fichiers")
        self.tabview.add("🏠 Dashboard")
        
        # Configuration des onglets
        self.create_definition_tab()
        self.create_solve_tab_modern()
        self.create_results_tab_modern()
        self.create_visualization_tab()
        self.create_files_tab_modern()
        self.create_dashboard_tab()
        
    def create_definition_tab(self):
        """Onglet de définition du problème moderne"""
        tab = self.tabview.tab("📝 Définition")
        
        # Scrollable frame
        self.def_scroll = ctk.CTkScrollableFrame(tab)
        self.def_scroll.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Titre avec animation
        title_frame = ctk.CTkFrame(self.def_scroll, fg_color="transparent")
        title_frame.pack(fill="x", pady=(0, 20))
        
        title = ctk.CTkLabel(
            title_frame,
            text="Définition du Problème de Programmation Linéaire",
            font=ctk.CTkFont(size=20, weight="bold")
        )
        title.pack()
        
        # Section dimensions avec style moderne
        dims_frame = ctk.CTkFrame(self.def_scroll, corner_radius=10)
        dims_frame.pack(fill="x", pady=(0, 20))
        
        dims_title = ctk.CTkLabel(
            dims_frame,
            text="📐 Dimensions du Problème",
            font=ctk.CTkFont(size=16, weight="bold")
        )
        dims_title.pack(pady=(15, 10))
        
        # Grille pour les dimensions
        dims_grid = ctk.CTkFrame(dims_frame, fg_color="transparent")
        dims_grid.pack(pady=(0, 15))
        
        # Variables
        vars_frame = ctk.CTkFrame(dims_grid, fg_color="transparent")
        vars_frame.grid(row=0, column=0, padx=20)
        
        ctk.CTkLabel(vars_frame, text="Variables:").pack()
        self.nb_vars_var = tk.StringVar(value="2")
        vars_spinbox = ctk.CTkEntry(
            vars_frame,
            textvariable=self.nb_vars_var,
            width=80,
            height=35,
            corner_radius=8
        )
        vars_spinbox.pack(pady=5)
        ToolTip(vars_spinbox, "Nombre de variables de décision (x₁, x₂, ...)")
        
        # Contraintes
        constr_frame = ctk.CTkFrame(dims_grid, fg_color="transparent")
        constr_frame.grid(row=0, column=1, padx=20)
        
        ctk.CTkLabel(constr_frame, text="Contraintes:").pack()
        self.nb_constraints_var = tk.StringVar(value="3")
        constr_spinbox = ctk.CTkEntry(
            constr_frame,
            textvariable=self.nb_constraints_var,
            width=80,
            height=35,
            corner_radius=8
        )
        constr_spinbox.pack(pady=5)
        ToolTip(constr_spinbox, "Nombre de contraintes du problème")
        
        # Bouton de génération avec animation
        generate_btn = AnimatedButton(
            dims_frame,
            text="🔄 Générer les Champs",
            command=self.generate_input_fields_modern,
            width=200,
            height=40,
            corner_radius=10,
            font=ctk.CTkFont(size=14, weight="bold")
        )
        generate_btn.pack(pady=(0, 15))
        
        # Frame pour les champs dynamiques
        self.fields_frame = ctk.CTkFrame(self.def_scroll, corner_radius=10)
        self.fields_frame.pack(fill="both", expand=True, pady=20)
        
        # Boutons d'action
        self.create_definition_actions()
        
    def generate_input_fields_modern(self):
        """Génère les champs de saisie avec un design moderne"""
        try:
            nb_vars = int(self.nb_vars_var.get())
            nb_constraints = int(self.nb_constraints_var.get())
        except ValueError:
            self.show_error("Veuillez entrer des nombres valides")
            return
        
        # Animation de chargement
        self.show_loading_animation(self.fields_frame)
        
        # Nettoyer le frame
        for widget in self.fields_frame.winfo_children():
            widget.destroy()
        
        self.problem_vars = []
        self.constraint_vars = []
        self.constraint_types = []
        
        # Fonction objectif avec style moderne
        obj_frame = ctk.CTkFrame(self.fields_frame, corner_radius=10)
        obj_frame.pack(fill="x", padx=20, pady=(20, 10))
        
        obj_title = ctk.CTkLabel(
            obj_frame,
            text="🎯 Fonction Objectif",
            font=ctk.CTkFont(size=16, weight="bold")
        )
        obj_title.pack(pady=(15, 10))
        
        # Type d'optimisation avec switch moderne
        opt_frame = ctk.CTkFrame(obj_frame, fg_color="transparent")
        opt_frame.pack(pady=(0, 15))
        
        self.opt_type_var = tk.StringVar(value="max")
        
        opt_selector = ctk.CTkSegmentedButton(
            opt_frame,
            values=["Maximiser", "Minimiser"],
            command=self.on_optimization_type_change
        )
        opt_selector.pack()
        opt_selector.set("Maximiser")
        
        # Coefficients avec style moderne
        coeffs_frame = ctk.CTkFrame(obj_frame, fg_color="transparent")
        coeffs_frame.pack(pady=(0, 15))
        
        ctk.CTkLabel(coeffs_frame, text="Z = ", font=ctk.CTkFont(size=14)).grid(row=0, column=0, padx=(0, 10))
        
        for i in range(nb_vars):
            if i > 0:
                ctk.CTkLabel(coeffs_frame, text="+", font=ctk.CTkFont(size=14)).grid(row=0, column=2*i, padx=5)
            
            var = tk.StringVar(value="1")
            entry = ctk.CTkEntry(
                coeffs_frame,
                textvariable=var,
                width=60,
                height=35,
                corner_radius=8,
                placeholder_text="Coef"
            )
            entry.grid(row=0, column=2*i+1, padx=2)
            self.problem_vars.append(var)
            
            ctk.CTkLabel(
                coeffs_frame, 
                text=f"x{self.subscript(i+1)}", 
                font=ctk.CTkFont(size=14)
            ).grid(row=0, column=2*i+2, padx=(2, 10))
        
        # Contraintes avec style moderne
        constraints_frame = ctk.CTkFrame(self.fields_frame, corner_radius=10)
        constraints_frame.pack(fill="x", padx=20, pady=10)
        
        constr_title = ctk.CTkLabel(
            constraints_frame,
            text="📋 Contraintes",
            font=ctk.CTkFont(size=16, weight="bold")
        )
        constr_title.pack(pady=(15, 10))
        
        # Conteneur pour les contraintes
        constr_container = ctk.CTkFrame(constraints_frame, fg_color="transparent")
        constr_container.pack(fill="x", padx=20, pady=(0, 15))
        
        for i in range(nb_constraints):
            # Frame pour chaque contrainte avec hover effect
            constraint_frame = ctk.CTkFrame(constr_container, corner_radius=8)
            constraint_frame.pack(fill="x", pady=5)
            
            # Effet au survol
            constraint_frame.bind("<Enter>", lambda e, f=constraint_frame: f.configure(fg_color=("gray85", "gray25")))
            constraint_frame.bind("<Leave>", lambda e, f=constraint_frame: f.configure(fg_color=("gray90", "gray20")))
            
            inner_frame = ctk.CTkFrame(constraint_frame, fg_color="transparent")
            inner_frame.pack(padx=15, pady=10)
            
            # Label de la contrainte
            ctk.CTkLabel(
                inner_frame, 
                text=f"C{self.subscript(i+1)}:",
                font=ctk.CTkFont(size=14, weight="bold")
            ).grid(row=0, column=0, padx=(0, 15))
            
            # Coefficients
            constraint_coeffs = []
            for j in range(nb_vars):
                if j > 0:
                    ctk.CTkLabel(inner_frame, text="+", font=ctk.CTkFont(size=14)).grid(row=0, column=2*j+1, padx=5)
                
                var = tk.StringVar(value="1")
                entry = ctk.CTkEntry(
                    inner_frame,
                    textvariable=var,
                    width=60,
                    height=35,
                    corner_radius=8,
                    placeholder_text="Coef"
                )
                entry.grid(row=0, column=2*j+2, padx=2)
                constraint_coeffs.append(var)
                
                ctk.CTkLabel(
                    inner_frame,
                    text=f"x{self.subscript(j+1)}",
                    font=ctk.CTkFont(size=14)
                ).grid(row=0, column=2*j+3, padx=(2, 10))
            
            # Type de contrainte avec dropdown moderne
            type_var = tk.StringVar(value="<=")
            type_menu = ctk.CTkOptionMenu(
                inner_frame,
                values=["<=", ">=", "="],
                variable=type_var,
                width=80,
                height=35,
                corner_radius=8
            )
            type_menu.grid(row=0, column=2*nb_vars+2, padx=10)
            self.constraint_types.append(type_var)
            
            # RHS
            rhs_var = tk.StringVar(value="0")
            rhs_entry = ctk.CTkEntry(
                inner_frame,
                textvariable=rhs_var,
                width=80,
                height=35,
                corner_radius=8,
                placeholder_text="RHS"
            )
            rhs_entry.grid(row=0, column=2*nb_vars+3, padx=(10, 0))
            constraint_coeffs.append(rhs_var)
            
            self.constraint_vars.append(constraint_coeffs)
        
        # Animation de fin
        self.hide_loading_animation()
        
    def subscript(self, n):
        """Convertit un nombre en indice"""
        subscripts = "₀₁₂₃₄₅₆₇₈₉"
        return ''.join(subscripts[int(d)] for d in str(n))
    
    def on_optimization_type_change(self, value):
        """Callback pour le changement de type d'optimisation"""
        self.opt_type_var.set("max" if value == "Maximiser" else "min")
        
    def create_definition_actions(self):
        """Crée les boutons d'action pour la définition"""
        actions_frame = ctk.CTkFrame(self.def_scroll, corner_radius=10)
        actions_frame.pack(fill="x", padx=20, pady=20)
        
        actions_inner = ctk.CTkFrame(actions_frame, fg_color="transparent")
        actions_inner.pack(pady=15)
        
        # Boutons avec animations
        buttons_data = [
            ("✅ Valider", self.validate_problem, "green", "Valider et sauvegarder le problème"),
            ("👁️ Aperçu", self.preview_problem, "blue", "Voir un aperçu du problème"),
            ("🗑️ Effacer", self.clear_problem, "red", "Effacer tous les champs"),
        ]
        
        for text, command, color, tooltip in buttons_data:
            btn = AnimatedButton(
                actions_inner,
                text=text,
                command=command,
                width=140,
                height=40,
                corner_radius=10,
                fg_color=color,
                font=ctk.CTkFont(size=14, weight="bold")
            )
            btn.pack(side="left", padx=10)
            ToolTip(btn, tooltip)
    
    def show_loading_animation(self, parent):
        """Affiche une animation de chargement"""
        self.loading_frame = ctk.CTkFrame(parent, fg_color="transparent")
        self.loading_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        self.loading_label = ctk.CTkLabel(
            self.loading_frame,
            text="⏳ Chargement...",
            font=ctk.CTkFont(size=16)
        )
        self.loading_label.pack()
        
        # Animation de rotation
        self.rotate_loading()
    
    def rotate_loading(self):
        """Animation de rotation pour le chargement"""
        if hasattr(self, 'loading_label'):
            symbols = ["⏳", "⌛", "⏳", "⌛"]
            current = self.loading_label.cget("text")
            idx = 0
            for i, s in enumerate(symbols):
                if s in current:
                    idx = (i + 1) % len(symbols)
                    break
            self.loading_label.configure(text=f"{symbols[idx]} Chargement...")
            self.root.after(500, self.rotate_loading)
    
    def hide_loading_animation(self):
        """Cache l'animation de chargement"""
        if hasattr(self, 'loading_frame'):
            self.loading_frame.destroy()
            
    def create_solve_tab_modern(self):
        """Onglet de résolution moderne"""
        tab = self.tabview.tab("🔍 Résolution")
        
        # Scrollable frame
        scroll_frame = ctk.CTkScrollableFrame(tab)
        scroll_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # État du problème
        status_frame = ctk.CTkFrame(scroll_frame, corner_radius=10)
        status_frame.pack(fill="x", pady=(0, 20))
        
        status_title = ctk.CTkLabel(
            status_frame,
            text="📊 État du Problème",
            font=ctk.CTkFont(size=18, weight="bold")
        )
        status_title.pack(pady=(15, 10))
        
        self.problem_status_label = ctk.CTkLabel(
            status_frame,
            text="❌ Aucun problème chargé",
            font=ctk.CTkFont(size=14)
        )
        self.problem_status_label.pack(pady=(0, 15))
        
        # Méthodes de résolution avec cartes modernes
        methods_frame = ctk.CTkFrame(scroll_frame, corner_radius=10)
        methods_frame.pack(fill="x", pady=(0, 20))
        
        methods_title = ctk.CTkLabel(
            methods_frame,
            text="🛠️ Méthodes de Résolution",
            font=ctk.CTkFont(size=18, weight="bold")
        )
        methods_title.pack(pady=(15, 10))
        
        # Grille de méthodes
        methods_grid = ctk.CTkFrame(methods_frame, fg_color="transparent")
        methods_grid.pack(pady=(0, 15))
        
        methods_data = [
            {
                "name": "Simplexe Standard",
                "icon": "📈",
                "desc": "Méthode classique pour problèmes standards",
                "command": self.solve_standard,
                "color": "blue",
                "shortcut": "F5"
            },
            {
                "name": "Grand M",
                "icon": "🎯",
                "desc": "Pour problèmes avec contraintes ≥ ou =",
                "command": self.solve_grand_m,
                "color": "green",
                "shortcut": "F6"
            },
            {
                "name": "Analyse Duale",
                "icon": "🔄",
                "desc": "Analyse primal-dual complète",
                "command": self.solve_dual,
                "color": "orange",
                "shortcut": "F7"
            }
        ]
        
        for i, method in enumerate(methods_data):
            self.create_method_card(methods_grid, method, i)
        
        # Comparaison des méthodes
        compare_btn = AnimatedButton(
            methods_frame,
            text="⚖️ Comparer Toutes les Méthodes",
            command=self.compare_methods,
            width=300,
            height=50,
            corner_radius=10,
            fg_color="purple",
            font=ctk.CTkFont(size=16, weight="bold")
        )
        compare_btn.pack(pady=(0, 15))
        
        # Progression
        self.create_progress_section(scroll_frame)
        
    def create_method_card(self, parent, method, index):
        """Crée une carte pour une méthode de résolution"""
        card = ctk.CTkFrame(parent, corner_radius=10, width=250, height=200)
        card.grid(row=0, column=index, padx=10, pady=10)
        card.grid_propagate(False)
        
        # Effet au survol
        card.bind("<Enter>", lambda e: card.configure(fg_color=("gray85", "gray25")))
        card.bind("<Leave>", lambda e: card.configure(fg_color=("gray90", "gray20")))
        
        # Icône
        icon_label = ctk.CTkLabel(
            card,
            text=method["icon"],
            font=ctk.CTkFont(size=40)
        )
        icon_label.pack(pady=(20, 10))
        
        # Nom
        name_label = ctk.CTkLabel(
            card,
            text=method["name"],
            font=ctk.CTkFont(size=16, weight="bold")
        )
        name_label.pack()
        
        # Description
        desc_label = ctk.CTkLabel(
            card,
            text=method["desc"],
            font=ctk.CTkFont(size=12),
            wraplength=200,
            text_color="gray"
        )
        desc_label.pack(pady=(5, 15))
        
        # Bouton
        btn = AnimatedButton(
            card,
            text=f"Lancer ({method['shortcut']})",
            command=method["command"],
            width=180,
            height=35,
            corner_radius=8,
            fg_color=method["color"]
        )
        btn.pack(pady=(0, 20))
        
    def create_progress_section(self, parent):
        """Crée la section de progression"""
        progress_frame = ctk.CTkFrame(parent, corner_radius=10)
        progress_frame.pack(fill="x", pady=(0, 20))
        
        progress_title = ctk.CTkLabel(
            progress_frame,
            text="⏳ Progression",
            font=ctk.CTkFont(size=18, weight="bold")
        )
        progress_title.pack(pady=(15, 10))
        
        self.progress_var = tk.StringVar(value="En attente...")
        self.progress_label = ctk.CTkLabel(
            progress_frame,
            textvariable=self.progress_var,
            font=ctk.CTkFont(size=14)
        )
        self.progress_label.pack()
        
        # Barre de progression moderne
        self.progress_bar = ctk.CTkProgressBar(
            progress_frame,
            width=400,
            height=20,
            corner_radius=10
        )
        self.progress_bar.pack(pady=(10, 15))
        self.progress_bar.set(0)
        
    def create_results_tab_modern(self):
        """Onglet des résultats moderne"""
        tab = self.tabview.tab("📊 Résultats")
        
        # Notebook pour les sous-onglets
        self.results_notebook = ctk.CTkTabview(tab, corner_radius=10)
        self.results_notebook.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Sous-onglets
        self.results_notebook.add("📝 Sortie Détaillée")
        self.results_notebook.add("📊 Tableau Final")
        self.results_notebook.add("📈 Graphiques")
        self.results_notebook.add("📋 Rapport")
        
        # Configuration des sous-onglets
        self.create_detailed_output_tab()
        self.create_final_tableau_tab()
        self.create_graphs_tab()
        self.create_report_tab()
        
    def create_detailed_output_tab(self):
        """Crée l'onglet de sortie détaillée"""
        tab = self.results_notebook.tab("📝 Sortie Détaillée")
        
        # Zone de texte moderne
        self.results_text = ctk.CTkTextbox(
            tab,
            font=ctk.CTkFont(family="Consolas", size=12),
            corner_radius=10
        )
        self.results_text.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Boutons d'action
        actions_frame = ctk.CTkFrame(tab, fg_color="transparent")
        actions_frame.pack(fill="x", padx=10, pady=(0, 10))
        
        copy_btn = AnimatedButton(
            actions_frame,
            text="📋 Copier",
            command=self.copy_results,
            width=100,
            height=35,
            corner_radius=8
        )
        copy_btn.pack(side="left", padx=5)
        
        save_btn = AnimatedButton(
            actions_frame,
            text="💾 Sauvegarder",
            command=self.save_results,
            width=100,
            height=35,
            corner_radius=8
        )
        save_btn.pack(side="left", padx=5)
        
    def create_final_tableau_tab(self):
        """Crée l'onglet du tableau final"""
        tab = self.results_notebook.tab("📊 Tableau Final")
        
        # Frame pour le tableau
        self.tableau_frame = ctk.CTkScrollableFrame(tab)
        self.tableau_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
    def create_graphs_tab(self):
        """Crée l'onglet des graphiques"""
        tab = self.results_notebook.tab("📈 Graphiques")
        
        # Frame pour les graphiques
        self.graphs_frame = ctk.CTkFrame(tab)
        self.graphs_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
    def create_report_tab(self):
        """Crée l'onglet du rapport"""
        tab = self.results_notebook.tab("📋 Rapport")
        
        # Frame pour le rapport
        self.report_frame = ctk.CTkScrollableFrame(tab)
        self.report_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
    def create_visualization_tab(self):
        """Onglet de visualisation avancée"""
        tab = self.tabview.tab("📈 Visualisation")
        
        # Notebook pour différents types de visualisations
        viz_notebook = ctk.CTkTabview(tab, corner_radius=10)
        viz_notebook.pack(fill="both", expand=True, padx=10, pady=10)
        
        viz_notebook.add("🎨 Région Réalisable")
        viz_notebook.add("📊 Analyse 3D")
        viz_notebook.add("🔄 Animation")
        viz_notebook.add("📈 Sensibilité")
        
        # Configuration des sous-onglets
        self.create_feasible_region_viz(viz_notebook.tab("🎨 Région Réalisable"))
        self.create_3d_analysis(viz_notebook.tab("📊 Analyse 3D"))
        self.create_animation_viz(viz_notebook.tab("🔄 Animation"))
        self.create_sensitivity_analysis(viz_notebook.tab("📈 Sensibilité"))
        
    def create_feasible_region_viz(self, parent):
        """Visualisation de la région réalisable"""
        control_frame = ctk.CTkFrame(parent)
        control_frame.pack(fill="x", padx=10, pady=10)
        
        # Contrôles
        ctk.CTkLabel(control_frame, text="Options de visualisation:").pack(side="left", padx=10)
        
        self.show_grid_var = tk.BooleanVar(value=True)
        grid_check = ctk.CTkCheckBox(
            control_frame,
            text="Grille",
            variable=self.show_grid_var,
            command=self.update_feasible_region
        )
        grid_check.pack(side="left", padx=10)
        
        self.show_optimal_var = tk.BooleanVar(value=True)
        optimal_check = ctk.CTkCheckBox(
            control_frame,
            text="Point optimal",
            variable=self.show_optimal_var,
            command=self.update_feasible_region
        )
        optimal_check.pack(side="left", padx=10)
        
        # Canvas pour matplotlib
        self.viz_frame = ctk.CTkFrame(parent)
        self.viz_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
    def create_3d_analysis(self, parent):
        """Analyse 3D pour problèmes à 3 variables"""
        info_label = ctk.CTkLabel(
            parent,
            text="📊 Visualisation 3D disponible pour les problèmes à 3 variables",
            font=ctk.CTkFont(size=14)
        )
        info_label.pack(pady=20)
        
        self.viz_3d_frame = ctk.CTkFrame(parent)
        self.viz_3d_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
    def create_animation_viz(self, parent):
        """Animation du processus de résolution"""
        control_frame = ctk.CTkFrame(parent)
        control_frame.pack(fill="x", padx=10, pady=10)
        
        play_btn = AnimatedButton(
            control_frame,
            text="▶️ Démarrer l'animation",
            command=self.start_solving_animation,
            width=200,
            height=40,
            corner_radius=8
        )
        play_btn.pack(side="left", padx=10)
        
        speed_label = ctk.CTkLabel(control_frame, text="Vitesse:").pack(side="left", padx=(20, 5))
        
        self.animation_speed = tk.DoubleVar(value=1.0)
        speed_slider = ctk.CTkSlider(
            control_frame,
            from_=0.1,
            to=3.0,
            variable=self.animation_speed,
            width=200
        )
        speed_slider.pack(side="left", padx=10)
        
        self.animation_frame = ctk.CTkFrame(parent)
        self.animation_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
    def create_sensitivity_analysis(self, parent):
        """Analyse de sensibilité"""
        info_label = ctk.CTkLabel(
            parent,
            text="📈 Analyse de sensibilité des paramètres",
            font=ctk.CTkFont(size=14)
        )
        info_label.pack(pady=20)
        
        self.sensitivity_frame = ctk.CTkFrame(parent)
        self.sensitivity_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
    def create_files_tab_modern(self):
        """Onglet de gestion des fichiers moderne"""
        tab = self.tabview.tab("💾 Fichiers")
        
        # Notebook pour organisation
        files_notebook = ctk.CTkTabview(tab, corner_radius=10)
        files_notebook.pack(fill="both", expand=True, padx=10, pady=10)
        
        files_notebook.add("📚 Historique")
        files_notebook.add("💾 Import/Export")
        files_notebook.add("☁️ Cloud")
        
        # Configuration des sous-onglets
        self.create_history_tab(files_notebook.tab("📚 Historique"))
        self.create_import_export_tab(files_notebook.tab("💾 Import/Export"))
        self.create_cloud_tab(files_notebook.tab("☁️ Cloud"))
        
    def create_history_tab(self, parent):
        """Crée l'onglet historique"""
        # Barre de recherche
        search_frame = ctk.CTkFrame(parent)
        search_frame.pack(fill="x", padx=10, pady=10)
        
        search_entry = ctk.CTkEntry(
            search_frame,
            placeholder_text="🔍 Rechercher dans l'historique...",
            width=300,
            height=35,
            corner_radius=8
        )
        search_entry.pack(side="left", padx=10)
        
        filter_btn = AnimatedButton(
            search_frame,
            text="🔽 Filtres",
            command=self.show_history_filters,
            width=100,
            height=35,
            corner_radius=8
        )
        filter_btn.pack(side="left")
        
        # Liste avec style moderne
        self.history_frame = ctk.CTkScrollableFrame(parent)
        self.history_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        self.refresh_history_modern()
        
    def create_import_export_tab(self, parent):
        """Crée l'onglet import/export"""
        # Section Import
        import_frame = ctk.CTkFrame(parent, corner_radius=10)
        import_frame.pack(fill="x", padx=10, pady=10)
        
        import_title = ctk.CTkLabel(
            import_frame,
            text="📥 Importer",
            font=ctk.CTkFont(size=16, weight="bold")
        )
        import_title.pack(pady=(15, 10))
        
        import_buttons = ctk.CTkFrame(import_frame, fg_color="transparent")
        import_buttons.pack(pady=(0, 15))
        
        formats = ["JSON", "CSV", "Excel", "LP"]
        for fmt in formats:
            btn = AnimatedButton(
                import_buttons,
                text=f"📄 {fmt}",
                command=lambda f=fmt: self.import_file(f),
                width=100,
                height=40,
                corner_radius=8
            )
            btn.pack(side="left", padx=5)
        
        # Section Export
        export_frame = ctk.CTkFrame(parent, corner_radius=10)
        export_frame.pack(fill="x", padx=10, pady=10)
        
        export_title = ctk.CTkLabel(
            export_frame,
            text="📤 Exporter",
            font=ctk.CTkFont(size=16, weight="bold")
        )
        export_title.pack(pady=(15, 10))
        
        export_buttons = ctk.CTkFrame(export_frame, fg_color="transparent")
        export_buttons.pack(pady=(0, 15))
        
        export_formats = ["PDF", "Excel", "LaTeX", "HTML"]
        for fmt in export_formats:
            btn = AnimatedButton(
                export_buttons,
                text=f"📄 {fmt}",
                command=lambda f=fmt: self.export_file(f),
                width=100,
                height=40,
                corner_radius=8
            )
            btn.pack(side="left", padx=5)
            
    def create_cloud_tab(self, parent):
        """Crée l'onglet cloud"""
        cloud_frame = ctk.CTkFrame(parent, corner_radius=10)
        cloud_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        cloud_icon = ctk.CTkLabel(
            cloud_frame,
            text="☁️",
            font=ctk.CTkFont(size=60)
        )
        cloud_icon.pack(pady=(30, 10))
        
        cloud_title = ctk.CTkLabel(
            cloud_frame,
            text="Stockage Cloud",
            font=ctk.CTkFont(size=20, weight="bold")
        )
        cloud_title.pack()
        
        cloud_desc = ctk.CTkLabel(
            cloud_frame,
            text="Synchronisez vos problèmes et résultats dans le cloud",
            font=ctk.CTkFont(size=14),
            text_color="gray"
        )
        cloud_desc.pack(pady=(5, 20))
        
        # Boutons de connexion
        services_frame = ctk.CTkFrame(cloud_frame, fg_color="transparent")
        services_frame.pack()
        
        cloud_services = [
            ("Google Drive", "green"),
            ("Dropbox", "blue"),
            ("OneDrive", "purple")
        ]
        
        for service, color in cloud_services:
            btn = AnimatedButton(
                services_frame,
                text=f"📁 {service}",
                command=lambda s=service: self.connect_cloud_service(s),
                width=150,
                height=40,
                corner_radius=8,
                fg_color=color
            )
            btn.pack(side="left", padx=10)
            
    def create_dashboard_tab(self):
        """Crée l'onglet dashboard"""
        tab = self.tabview.tab("🏠 Dashboard")
        
        scroll = ctk.CTkScrollableFrame(tab)
        scroll.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Titre
        title = ctk.CTkLabel(
            scroll,
            text="📊 Tableau de Bord",
            font=ctk.CTkFont(size=24, weight="bold")
        )
        title.pack(pady=(0, 20))
        
        # Statistiques en cartes
        stats_grid = ctk.CTkFrame(scroll, fg_color="transparent")
        stats_grid.pack(fill="x", pady=(0, 20))
        
        self.create_stat_cards(stats_grid)
        
        # Graphiques
        graphs_frame = ctk.CTkFrame(scroll, corner_radius=10)
        graphs_frame.pack(fill="both", expand=True)
        
        self.create_dashboard_graphs(graphs_frame)
        
    def create_stat_cards(self, parent):
        """Crée les cartes de statistiques"""
        stats = [
            {
                "title": "Problèmes Résolus",
                "value": str(self.stats['problems_solved']),
                "icon": "✅",
                "color": "green"
            },
            {
                "title": "Temps Moyen",
                "value": f"{self.stats['avg_solving_time']:.2f}s",
                "icon": "⏱️",
                "color": "blue"
            },
            {
                "title": "Méthode Favorite",
                "value": max(self.stats['methods_used'], key=self.stats['methods_used'].get),
                "icon": "🏆",
                "color": "orange"
            },
            {
                "title": "Taux de Succès",
                "value": "100%",
                "icon": "📈",
                "color": "purple"
            }
        ]
        
        for i, stat in enumerate(stats):
            card = self.create_stat_card(parent, stat)
            card.grid(row=0, column=i, padx=10, pady=10, sticky="nsew")
            parent.grid_columnconfigure(i, weight=1)
            
    def create_stat_card(self, parent, stat):
        """Crée une carte de statistique"""
        card = ctk.CTkFrame(parent, corner_radius=10, height=150)
        card.grid_propagate(False)
        
        # Icône
        icon_label = ctk.CTkLabel(
            card,
            text=stat["icon"],
            font=ctk.CTkFont(size=30)
        )
        icon_label.pack(pady=(20, 5))
        
        # Valeur
        value_label = ctk.CTkLabel(
            card,
            text=stat["value"],
            font=ctk.CTkFont(size=24, weight="bold"),
            text_color=stat["color"]
        )
        value_label.pack()
        
        # Titre
        title_label = ctk.CTkLabel(
            card,
            text=stat["title"],
            font=ctk.CTkFont(size=12),
            text_color="gray"
        )
        title_label.pack(pady=(5, 20))
        
        return card
        
    def create_dashboard_graphs(self, parent):
        """Crée les graphiques du dashboard"""
        graphs_title = ctk.CTkLabel(
            parent,
            text="📈 Analyses Graphiques",
            font=ctk.CTkFont(size=18, weight="bold")
        )
        graphs_title.pack(pady=(15, 10))
        
        # Frame pour les graphiques matplotlib
        self.dashboard_graphs_frame = ctk.CTkFrame(parent, fg_color="transparent")
        self.dashboard_graphs_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Créer les graphiques
        self.create_methods_pie_chart()
        self.create_time_series_chart()
        
    def create_methods_pie_chart(self):
        """Crée un graphique en secteurs des méthodes utilisées"""
        fig, ax = plt.subplots(figsize=(6, 4))
        
        methods = list(self.stats['methods_used'].keys())
        values = list(self.stats['methods_used'].values())
        
        if sum(values) > 0:
            ax.pie(values, labels=methods, autopct='%1.1f%%', startangle=90)
        else:
            ax.text(0.5, 0.5, 'Aucune donnée', ha='center', va='center', transform=ax.transAxes)
        
        ax.set_title("Répartition des Méthodes Utilisées")
        
        canvas = FigureCanvasTkAgg(fig, self.dashboard_graphs_frame)
        canvas.draw()
        canvas.get_tk_widget().pack(side="left", padx=10, pady=10)
        
    def create_time_series_chart(self):
        """Crée un graphique temporel"""
        fig, ax = plt.subplots(figsize=(6, 4))
        
        # Données simulées
        dates = pd.date_range(end=datetime.now(), periods=30, freq='D')
        values = np.random.randint(0, 10, 30)
        
        ax.plot(dates, values, marker='o', linestyle='-', linewidth=2, markersize=6)
        ax.set_title("Problèmes Résolus par Jour")
        ax.set_xlabel("Date")
        ax.set_ylabel("Nombre de Problèmes")
        ax.grid(True, alpha=0.3)
        
        fig.autofmt_xdate()
        
        canvas = FigureCanvasTkAgg(fig, self.dashboard_graphs_frame)
        canvas.draw()
        canvas.get_tk_widget().pack(side="right", padx=10, pady=10)
        
    def create_status_bar(self):
        """Crée une barre de statut moderne"""
        self.status_bar = ctk.CTkFrame(self.main_container, height=30, corner_radius=0)
        self.status_bar.grid(row=2, column=0, sticky="ew")
        self.status_bar.grid_columnconfigure(1, weight=1)
        
        # Statut à gauche
        self.status_label = ctk.CTkLabel(
            self.status_bar,
            text="✅ Prêt",
            font=ctk.CTkFont(size=12)
        )
        self.status_label.grid(row=0, column=0, padx=20)
        
        # Info au centre
        self.info_label = ctk.CTkLabel(
            self.status_bar,
            text="",
            font=ctk.CTkFont(size=12)
        )
        self.info_label.grid(row=0, column=1)
        
        # Heure à droite
        self.time_label = ctk.CTkLabel(
            self.status_bar,
            text="",
            font=ctk.CTkFont(size=12)
        )
        self.time_label.grid(row=0, column=2, padx=20)
        
        self.update_time()
        
    def update_time(self):
        """Met à jour l'heure dans la barre de statut"""
        current_time = datetime.now().strftime("%H:%M:%S")
        self.time_label.configure(text=f"🕐 {current_time}")
        self.root.after(1000, self.update_time)
        
    def toggle_theme(self):
        """Bascule entre thème clair et sombre"""
        self.theme.toggle()
        
        # Mettre à jour l'icône du switch
        if self.theme.dark_mode:
            self.theme_switch.configure(text="🌙")
        else:
            self.theme_switch.configure(text="☀️")
            
    def show_dashboard(self):
        """Affiche le dashboard"""
        self.tabview.set("🏠 Dashboard")
        
    def focus_solve_tab(self):
        """Focus sur l'onglet de résolution"""
        self.tabview.set("🔍 Résolution")
        
    def show_visualization(self):
        """Affiche les visualisations"""
        self.tabview.set("📈 Visualisation")
        
    def show_history(self):
        """Affiche l'historique"""
        self.tabview.set("💾 Fichiers")
        
    def show_settings(self):
        """Affiche les paramètres"""
        settings_window = ctk.CTkToplevel(self.root)
        settings_window.title("⚙️ Paramètres")
        settings_window.geometry("600x500")
        settings_window.transient(self.root)
        settings_window.grab_set()
        
        # Centrer la fenêtre
        settings_window.update_idletasks()
        x = (settings_window.winfo_screenwidth() // 2) - 300
        y = (settings_window.winfo_screenheight() // 2) - 250
        settings_window.geometry(f"600x500+{x}+{y}")
        
        # Contenu des paramètres
        settings_frame = ctk.CTkFrame(settings_window)
        settings_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        title = ctk.CTkLabel(
            settings_frame,
            text="⚙️ Paramètres",
            font=ctk.CTkFont(size=20, weight="bold")
        )
        title.pack(pady=(0, 20))
        
        # Options
        options = [
            ("Sauvegarde automatique", self.auto_save_enabled),
            ("Animations", True),
            ("Sons", False),
            ("Tooltips", True)
        ]
        
        for option, default in options:
            var = tk.BooleanVar(value=default)
            switch = ctk.CTkSwitch(
                settings_frame,
                text=option,
                variable=var
            )
            switch.pack(pady=10)
            
        # Bouton fermer
        close_btn = AnimatedButton(
            settings_frame,
            text="✅ Fermer",
            command=settings_window.destroy,
            width=150,
            height=40,
            corner_radius=8
        )
        close_btn.pack(pady=(20, 0))
        
    def show_help(self):
        """Affiche l'aide"""
        help_window = ctk.CTkToplevel(self.root)
        help_window.title("❓ Aide")
        help_window.geometry("700x600")
        help_window.transient(self.root)
        
        # Contenu de l'aide
        help_frame = ctk.CTkScrollableFrame(help_window)
        help_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        title = ctk.CTkLabel(
            help_frame,
            text="📚 Guide d'Utilisation",
            font=ctk.CTkFont(size=20, weight="bold")
        )
        title.pack(pady=(0, 20))
        
        # Sections d'aide
        help_sections = [
            {
                "title": "🚀 Démarrage Rapide",
                "content": "1. Définissez le nombre de variables et contraintes\n"
                          "2. Remplissez les coefficients\n"
                          "3. Choisissez une méthode de résolution\n"
                          "4. Consultez les résultats"
            },
            {
                "title": "⌨️ Raccourcis Clavier",
                "content": "Ctrl+N : Nouveau problème\n"
                          "Ctrl+O : Ouvrir un fichier\n"
                          "Ctrl+S : Sauvegarder\n"
                          "F5 : Simplexe Standard\n"
                          "F6 : Grand M\n"
                          "F7 : Analyse Duale\n"
                          "F11 : Plein écran"
            },
            {
                "title": "💡 Conseils",
                "content": "• Utilisez Grand M pour les contraintes ≥ ou =\n"
                          "• La visualisation fonctionne mieux avec 2 variables\n"
                          "• Exportez vos résultats en PDF pour les rapports"
            }
        ]
        
        for section in help_sections:
            section_frame = ctk.CTkFrame(help_frame, corner_radius=10)
            section_frame.pack(fill="x", pady=10)
            
            section_title = ctk.CTkLabel(
                section_frame,
                text=section["title"],
                font=ctk.CTkFont(size=16, weight="bold")
            )
            section_title.pack(pady=(10, 5))
            
            section_content = ctk.CTkLabel(
                section_frame,
                text=section["content"],
                font=ctk.CTkFont(size=12),
                justify="left"
            )
            section_content.pack(pady=(5, 10), padx=20)
            
    def show_statistics(self):
        """Affiche les statistiques détaillées"""
        stats_window = ctk.CTkToplevel(self.root)
        stats_window.title("📈 Statistiques")
        stats_window.geometry("800x600")
        stats_window.transient(self.root)
        
        # Contenu
        stats_frame = ctk.CTkFrame(stats_window)
        stats_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        title = ctk.CTkLabel(
            stats_frame,
            text="📈 Statistiques Détaillées",
            font=ctk.CTkFont(size=20, weight="bold")
        )
        title.pack(pady=(0, 20))
        
        # Créer des graphiques statistiques avec plotly
        self.create_plotly_stats(stats_frame)
        
    def create_plotly_stats(self, parent):
        """Crée des graphiques statistiques avec Plotly"""
        # Données simulées
        methods = list(self.stats['methods_used'].keys())
        values = list(self.stats['methods_used'].values())
        
        # Graphique en barres
        fig = go.Figure(data=[
            go.Bar(x=methods, y=values, marker_color=['blue', 'green', 'orange'])
        ])
        
        fig.update_layout(
            title="Utilisation des Méthodes",
            xaxis_title="Méthode",
            yaxis_title="Nombre d'utilisations",
            template="plotly_dark" if self.theme.dark_mode else "plotly_white"
        )
        
        # Sauvegarder et afficher
        fig.write_html("temp_stats.html")
        webbrowser.open("temp_stats.html")
        
    def customize_interface(self):
        """Personnalise l'interface"""
        custom_window = ctk.CTkToplevel(self.root)
        custom_window.title("🎨 Personnalisation")
        custom_window.geometry("500x400")
        custom_window.transient(self.root)
        
        frame = ctk.CTkFrame(custom_window)
        frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        title = ctk.CTkLabel(
            frame,
            text="🎨 Personnaliser l'Interface",
            font=ctk.CTkFont(size=20, weight="bold")
        )
        title.pack(pady=(0, 20))
        
        # Options de couleur
        color_label = ctk.CTkLabel(
            frame,
            text="Thème de couleur:",
            font=ctk.CTkFont(size=14)
        )
        color_label.pack(pady=(0, 10))
        
        color_options = ctk.CTkSegmentedButton(
            frame,
            values=["Bleu", "Vert", "Rouge", "Violet"],
            command=self.change_color_theme
        )
        color_options.pack(pady=(0, 20))
        color_options.set("Bleu")
        
        # Taille de police
        font_label = ctk.CTkLabel(
            frame,
            text="Taille de police:",
            font=ctk.CTkFont(size=14)
        )
        font_label.pack(pady=(0, 10))
        
        font_slider = ctk.CTkSlider(
            frame,
            from_=10,
            to=20,
            command=self.change_font_size
        )
        font_slider.pack(pady=(0, 20))
        
    def change_color_theme(self, value):
        """Change le thème de couleur"""
        themes = {
            "Bleu": "blue",
            "Vert": "green",
            "Rouge": "dark-blue",
            "Violet": "blue"
        }
        ctk.set_default_color_theme(themes.get(value, "blue"))
        
    def change_font_size(self, value):
        """Change la taille de police"""
        # Implémenter le changement de taille de police
        pass
        
    def export_to_pdf(self):
        """Exporte les résultats en PDF"""
        if not hasattr(self, 'last_result'):
            self.show_error("Aucun résultat à exporter")
            return
            
        filename = filedialog.asksaveasfilename(
            title="Exporter en PDF",
            defaultextension=".pdf",
            filetypes=[("PDF", "*.pdf")]
        )
        
        if filename:
            self.create_pdf_report(filename)
            
    def create_pdf_report(self, filename):
        """Crée un rapport PDF professionnel"""
        doc = SimpleDocTemplate(filename, pagesize=A4)
        elements = []
        styles = getSampleStyleSheet()
        
        # Titre
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=24,
            textColor=colors.HexColor('#2E86AB'),
            alignment=1
        )
        
        title = Paragraph("Rapport de Programmation Linéaire", title_style)
        elements.append(title)
        elements.append(Spacer(1, 30))
        
        # Informations
        info_text = f"""
        <b>Date:</b> {datetime.now().strftime('%d/%m/%Y %H:%M')}<br/>
        <b>Méthode:</b> {self.last_result.get('method', 'N/A')}<br/>
        <b>Statut:</b> Résolu avec succès
        """
        info = Paragraph(info_text, styles['Normal'])
        elements.append(info)
        elements.append(Spacer(1, 20))
        
        # Résultats
        results_title = Paragraph("Résultats", styles['Heading2'])
        elements.append(results_title)
        elements.append(Spacer(1, 10))
        
        # Contenu des résultats
        results_text = self.last_result.get('output', 'Aucun résultat')
        # Limiter la longueur pour le PDF
        if len(results_text) > 5000:
            results_text = results_text[:5000] + "\n... (tronqué)"
        
        results_para = Paragraph(
            f"<pre>{results_text}</pre>",
            styles['Code']
        )
        elements.append(results_para)
        
        # Générer le PDF
        try:
            doc.build(elements)
            self.show_success(f"PDF exporté: {filename}")
        except Exception as e:
            self.show_error(f"Erreur lors de l'export PDF: {e}")
            
    def refresh_history_modern(self):
        """Actualise l'historique avec un design moderne"""
        # Nettoyer
        for widget in self.history_frame.winfo_children():
            widget.destroy()
            
        # Afficher l'historique
        for i, problem in enumerate(self.variable_manager.history):
            self.create_history_card(problem, i)
            
    def create_history_card(self, problem, index):
        """Crée une carte d'historique moderne"""
        card = ctk.CTkFrame(self.history_frame, corner_radius=10)
        card.pack(fill="x", padx=10, pady=5)
        
        # Effet au survol
        card.bind("<Enter>", lambda e: card.configure(fg_color=("gray85", "gray25")))
        card.bind("<Leave>", lambda e: card.configure(fg_color=("gray90", "gray20")))
        
        # Contenu
        content_frame = ctk.CTkFrame(card, fg_color="transparent")
        content_frame.pack(fill="x", padx=15, pady=10)
        
        # Infos principales
        method = problem.get('method', '?')
        timestamp = problem.get('timestamp', '?')
        metadata = problem.get('metadata', {})
        
        # Titre et méthode
        title_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        title_frame.pack(fill="x")
        
        method_label = ctk.CTkLabel(
            title_frame,
            text=f"🔧 {method}",
            font=ctk.CTkFont(size=14, weight="bold")
        )
        method_label.pack(side="left")
        
        time_label = ctk.CTkLabel(
            title_frame,
            text=timestamp,
            font=ctk.CTkFont(size=12),
            text_color="gray"
        )
        time_label.pack(side="right")
        
        # Détails
        details_text = f"Variables: {metadata.get('nb_variables', '?')} | Contraintes: {metadata.get('nb_contraintes', '?')}"
        details_label = ctk.CTkLabel(
            content_frame,
            text=details_text,
            font=ctk.CTkFont(size=12),
            text_color="gray"
        )
        details_label.pack(anchor="w", pady=(5, 0))
        
        # Boutons d'action
        actions_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        actions_frame.pack(fill="x", pady=(10, 0))
        
        load_btn = AnimatedButton(
            actions_frame,
            text="📂 Charger",
            command=lambda: self.load_from_history(index),
            width=80,
            height=30,
            corner_radius=6
        )
        load_btn.pack(side="left", padx=(0, 5))
        
        delete_btn = AnimatedButton(
            actions_frame,
            text="🗑️",
            command=lambda: self.delete_from_history(index),
            width=40,
            height=30,
            corner_radius=6,
            fg_color="red"
        )
        delete_btn.pack(side="left")
        
    def show_error(self, message):
        """Affiche un message d'erreur moderne"""
        self.show_notification(message, "error")
        
    def show_success(self, message):
        """Affiche un message de succès moderne"""
        self.show_notification(message, "success")
        
    def show_notification(self, message, type="info"):
        """Affiche une notification moderne"""
        colors = {
            "info": "blue",
            "success": "green",
            "error": "red",
            "warning": "orange"
        }
        
        notification = ctk.CTkFrame(
            self.root,
            corner_radius=10,
            fg_color=colors.get(type, "blue"),
            width=300,
            height=60
        )
        
        notification.place(relx=0.5, rely=0.1, anchor="center")
        notification.lift()
        
        msg_label = ctk.CTkLabel(
            notification,
            text=message,
            font=ctk.CTkFont(size=14, weight="bold"),
            text_color="white"
        )
        msg_label.pack(expand=True)
        
        # Animation de disparition
        self.root.after(3000, notification.destroy)
        
    def update_feasible_region(self):
        """Met à jour la visualisation de la région réalisable"""
        if not self.current_problem or self.current_problem["nombres_variables_base"] != 2:
            return
            
        # Nettoyer le frame
        for widget in self.viz_frame.winfo_children():
            widget.destroy()
            
        # Créer le graphique
        fig, ax = plt.subplots(figsize=(8, 6))
        
        # Configuration du style
        if self.theme.dark_mode:
            plt.style.use('dark_background')
        else:
            plt.style.use('default')
            
        # Tracer les contraintes
        self.plot_constraints(ax)
        
        # Options
        if self.show_grid_var.get():
            ax.grid(True, alpha=0.3)
            
        if self.show_optimal_var.get():
            # Ajouter le point optimal (simulé)
            ax.plot(5, 5, 'ro', markersize=10, label='Point Optimal')
            
        ax.set_xlabel('x₁', fontsize=12)
        ax.set_ylabel('x₂', fontsize=12)
        ax.set_title('Région Réalisable', fontsize=14, fontweight='bold')
        ax.legend()
        
        # Intégrer dans tkinter
        canvas = FigureCanvasTkAgg(fig, self.viz_frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True)
        
        # Toolbar
        toolbar = NavigationToolbar2Tk(canvas, self.viz_frame)
        toolbar.update()
        
    def plot_constraints(self, ax):
        """Trace les contraintes sur le graphique"""
        x = np.linspace(0, 20, 400)
        equations = self.current_problem["equations"]
        constraints_info = self.current_problem.get("constraints_info", [])
        
        colors = ['red', 'blue', 'green', 'orange', 'purple']
        
        for i, (key, eq) in enumerate(equations.items()):
            if len(eq) >= 3:
                rhs = eq[0]
                a1, a2 = eq[1], eq[2]
                
                if a2 != 0:
                    y = (rhs - a1 * x) / a2
                    
                    # Filtrer les valeurs négatives
                    valid_mask = (y >= 0) & (x >= 0)
                    
                    constraint_type = constraints_info[i] if i < len(constraints_info) else "<="
                    label = f"C{i+1}: {a1}x₁ + {a2}x₂ {constraint_type} {rhs}"
                    
                    ax.plot(x[valid_mask], y[valid_mask], 
                           color=colors[i % len(colors)], 
                           label=label, linewidth=2)
                    
                    # Zone réalisable
                    if constraint_type == "<=":
                        ax.fill_between(x[valid_mask], 0, y[valid_mask], 
                                      color=colors[i % len(colors)], alpha=0.1)
                                      
    def start_solving_animation(self):
        """Démarre l'animation du processus de résolution"""
        # Nettoyer le frame
        for widget in self.animation_frame.winfo_children():
            widget.destroy()
            
        # Créer l'animation
        fig, ax = plt.subplots(figsize=(8, 6))
        
        # Animation simulée du simplexe
        self.animation_step = 0
        self.animation_points = [(0, 0), (2, 3), (4, 5), (6, 4), (8, 2)]
        
        line, = ax.plot([], [], 'ro-', markersize=8)
        
        def init():
            ax.set_xlim(0, 10)
            ax.set_ylim(0, 10)
            ax.set_xlabel('x₁')
            ax.set_ylabel('x₂')
            ax.set_title('Animation du Simplexe')
            ax.grid(True, alpha=0.3)
            return line,
            
        def animate(frame):
            if frame < len(self.animation_points):
                x_data = [p[0] for p in self.animation_points[:frame+1]]
                y_data = [p[1] for p in self.animation_points[:frame+1]]
                line.set_data(x_data, y_data)
            return line,
            
        anim = FuncAnimation(
            fig, animate, init_func=init,
            frames=len(self.animation_points),
            interval=1000/self.animation_speed.get(),
            blit=True,
            repeat=True
        )
        
        # Intégrer dans tkinter
        canvas = FigureCanvasTkAgg(fig, self.animation_frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True)
        
    def copy_results(self):
        """Copie les résultats dans le presse-papier"""
        if hasattr(self, 'results_text'):
            content = self.results_text.get(1.0, tk.END)
            self.root.clipboard_clear()
            self.root.clipboard_append(content)
            self.show_success("✅ Résultats copiés!")
            
    def load_from_history(self, index):
        """Charge un problème depuis l'historique"""
        variables = self.variable_manager.get_problem(index)
        if variables:
            self.current_problem = variables
            self.update_solve_tab()
            self.show_success("✅ Problème chargé!")
            self.tabview.set("🔍 Résolution")
            
    def delete_from_history(self, index):
        """Supprime un problème de l'historique"""
        if messagebox.askyesno("Confirmation", "Supprimer ce problème ?"):
            if self.variable_manager.delete_problem(index):
                self.refresh_history_modern()
                self.show_success("✅ Problème supprimé!")
                
    def show_history_filters(self):
        """Affiche les filtres d'historique"""
        # Implémenter les filtres d'historique
        pass
        
    def import_file(self, format):
        """Importe un fichier selon le format"""
        filetypes = {
            "JSON": [("JSON", "*.json")],
            "CSV": [("CSV", "*.csv")],
            "Excel": [("Excel", "*.xlsx")],
            "LP": [("LP", "*.lp")]
        }
        
        filename = filedialog.askopenfilename(
            title=f"Importer {format}",
            filetypes=filetypes.get(format, [])
        )
        
        if filename:
            # Implémenter l'import selon le format
            self.show_success(f"✅ Fichier {format} importé!")
            
    def export_file(self, format):
        """Exporte vers un fichier selon le format"""
        if not self.current_problem:
            self.show_error("Aucun problème à exporter")
            return
            
        # Implémenter l'export selon le format
        self.show_success(f"✅ Export {format} réussi!")
        
    def connect_cloud_service(self, service):
        """Connecte un service cloud"""
        self.show_notification(f"Connexion à {service}...", "info")
        # Implémenter la connexion cloud
        
    def load_stats(self):
        """Charge les statistiques sauvegardées"""
        try:
            with open("stats.json", "r") as f:
                saved_stats = json.load(f)
                self.stats.update(saved_stats)
        except:
            pass
            
    def save_stats(self):
        """Sauvegarde les statistiques"""
        try:
            with open("stats.json", "w") as f:
                json.dump(self.stats, f)
        except:
            pass
            
    def on_closing(self):
        """Gestion de la fermeture de l'application"""
        if messagebox.askokcancel("Quitter", "Voulez-vous vraiment quitter ?"):
            self.save_stats()
            self.root.quit()
            self.root.destroy()
            
    # Méthodes existantes adaptées
    def validate_problem(self):
        """Valide et construit le problème de PL"""
        try:
            nb_vars = int(self.nb_vars_var.get())
            nb_constraints = int(self.nb_constraints_var.get())
            
            # Construire la fonction objectif
            obj_coeffs = [0]  # Constante
            for var in self.problem_vars:
                coeff = float(var.get())
                if self.opt_type_var.get() == "min":
                    coeff = -coeff  # Conversion min -> max
                obj_coeffs.append(coeff)
            
            # Construire les contraintes
            equations = {}
            constraints_info = []
            
            for i, (constraint_coeffs, constraint_type) in enumerate(zip(self.constraint_vars, self.constraint_types)):
                # RHS en premier, puis coefficients
                rhs = float(constraint_coeffs[-1].get())
                coeffs = [rhs]
                
                for j in range(nb_vars):
                    coeffs.append(float(constraint_coeffs[j].get()))
                
                equations[f"equation_{i+1}"] = coeffs
                constraints_info.append(constraint_type.get())
            
            # Créer le dictionnaire du problème
            self.current_problem = {
                "tab_optimisation": obj_coeffs,
                "nombres_variables_base": nb_vars,
                "equations": equations,
                "nb_equations": nb_constraints,
                "constraints_info": constraints_info,
                "objective_type": self.opt_type_var.get(),
                "method_type": "Interface Graphique"
            }
            
            # Sauvegarder dans l'historique
            self.variable_manager.save_problem(self.current_problem, "Interface Graphique")
            
            # Statistiques
            self.stats['problems_solved'] += 1
            
            self.show_success("✅ Problème validé et sauvegardé!")
            
            # Passer à l'onglet de résolution
            self.tabview.set("🔍 Résolution")
            self.update_solve_tab()
            
        except ValueError as e:
            self.show_error(f"Erreur dans les données: {e}")
        except Exception as e:
            self.show_error(f"Erreur inattendue: {e}")
    
    def update_solve_tab(self):
        """Met à jour l'onglet de résolution avec les infos du problème"""
        if self.current_problem:
            nb_vars = self.current_problem["nombres_variables_base"]
            nb_constraints = self.current_problem["nb_equations"]
            obj_type = self.current_problem.get("objective_type", "max")
            
            info_text = f"✅ Problème défini: {nb_vars} variables, {nb_constraints} contraintes ({obj_type}imisation)"
            
            # Suggestion de méthode
            constraints_info = self.current_problem.get("constraints_info", [])
            if any(c in [">=", "="] for c in constraints_info):
                info_text += "\n💡 Méthode suggérée: Grand M"
            else:
                info_text += "\n💡 Méthode suggérée: Simplexe Standard"
            
            self.problem_status_label.configure(text=info_text)
            self.status_label.configure(text="✅ Problème chargé")
        else:
            self.problem_status_label.configure(text="❌ Aucun problème chargé")
            self.status_label.configure(text="⚠️ Aucun problème")
    
    def solve_standard(self):
        """Résolution par simplexe standard"""
        if not self.current_problem:
            self.show_error("Veuillez d'abord définir un problème")
            return
        
        self.run_solver("Simplexe Standard", self._solve_standard_worker)
    
    def solve_grand_m(self):
        """Résolution par Grand M"""
        if not self.current_problem:
            self.show_error("Veuillez d'abord définir un problème")
            return
        
        self.run_solver("Grand M", self._solve_grand_m_worker)
    
    def solve_dual(self):
        """Analyse primal-dual"""
        if not self.current_problem:
            self.show_error("Veuillez d'abord définir un problème")
            return
        
        self.run_solver("Analyse Duale", self._solve_dual_worker)
    
    def run_solver(self, method_name, worker_func):
        """Lance la résolution dans un thread séparé"""
        self.progress_var.set(f"🔄 Résolution en cours ({method_name})...")
        self.progress_bar.set(0)
        self.status_label.configure(text=f"⏳ {method_name} en cours...")
        
        # Animation de progression
        self.animate_progress = True
        self.animate_progress_bar()
        
        # Thread pour éviter de bloquer l'interface
        thread = threading.Thread(target=worker_func, args=(method_name,))
        thread.daemon = True
        thread.start()
    
    def animate_progress_bar(self):
        """Anime la barre de progression"""
        if hasattr(self, 'animate_progress') and self.animate_progress:
            current = self.progress_bar.get()
            if current >= 1.0:
                self.progress_bar.set(0)
            else:
                self.progress_bar.set(current + 0.05)
            self.root.after(100, self.animate_progress_bar)
    
    def _solve_standard_worker(self, method_name):
        """Worker pour simplexe standard"""
        try:
            import copy
            import time
            start_time = time.time()
            
            problem_copy = copy.deepcopy(self.current_problem)
            solver = SimplexMethodTab(problem_copy)
            
            # Capturer la sortie
            result = self.capture_solver_output(solver.run)
            
            # Calculer le temps écoulé
            elapsed_time = time.time() - start_time
            
            # Mettre à jour les statistiques
            self.stats['methods_used']['Simplexe'] += 1
            self.stats['avg_solving_time'] = (self.stats['avg_solving_time'] + elapsed_time) / 2
            
            # Mettre à jour l'interface dans le thread principal
            self.root.after(0, self._solver_completed, method_name, result, problem_copy, elapsed_time)
            
        except Exception as e:
            self.root.after(0, self._solver_error, method_name, str(e))
    
    def _solve_grand_m_worker(self, method_name):
        """Worker pour Grand M"""
        try:
            import copy
            import time
            start_time = time.time()
            
            problem_copy = copy.deepcopy(self.current_problem)
            solver = GrandMMethod(problem_copy)
            
            result = self.capture_solver_output(solver.run)
            
            elapsed_time = time.time() - start_time
            
            self.stats['methods_used']['Grand M'] += 1
            self.stats['avg_solving_time'] = (self.stats['avg_solving_time'] + elapsed_time) / 2
            
            self.root.after(0, self._solver_completed, method_name, result, problem_copy, elapsed_time)
            
        except Exception as e:
            self.root.after(0, self._solver_error, method_name, str(e))
    
    def _solve_dual_worker(self, method_name):
        """Worker pour analyse duale"""
        try:
            import copy
            import time
            start_time = time.time()
            
            problem_copy = copy.deepcopy(self.current_problem)
            analyzer = DualMethod(problem_copy)
            
            result = self.capture_solver_output(analyzer.run_complete_analysis)
            
            elapsed_time = time.time() - start_time
            
            self.stats['methods_used']['Dual'] += 1
            self.stats['avg_solving_time'] = (self.stats['avg_solving_time'] + elapsed_time) / 2
            
            self.root.after(0, self._solver_completed, method_name, result, problem_copy, elapsed_time)
            
        except Exception as e:
            self.root.after(0, self._solver_error, method_name, str(e))
    
    def capture_solver_output(self, solver_func):
        """Capture la sortie de la console"""
        import io
        import contextlib
        
        output = io.StringIO()
        with contextlib.redirect_stdout(output):
            solver_func()
        
        return output.getvalue()
    
    def _solver_completed(self, method_name, result, final_problem, elapsed_time):
        """Callback quand la résolution est terminée"""
        self.animate_progress = False
        self.progress_bar.set(1.0)
        self.progress_var.set(f"✅ {method_name} terminé en {elapsed_time:.2f}s!")
        self.status_label.configure(text="✅ Résolution terminée")
        
        # Stocker le résultat
        self.last_result = {
            'method': method_name,
            'output': result,
            'problem': final_problem,
            'timestamp': datetime.now(),
            'elapsed_time': elapsed_time
        }
        
        # Mise à jour des statistiques
        self.update_stats_display()
        
        # Passer à l'onglet des résultats
        self.tabview.set("📊 Résultats")
        self.display_results()
        
        # Notification
        self.show_success(f"✅ {method_name} terminé en {elapsed_time:.2f}s!")
        
        # Visualisation automatique si 2 variables
        if self.current_problem["nombres_variables_base"] == 2:
            self.update_feasible_region()
    
    def _solver_error(self, method_name, error_msg):
        """Callback en cas d'erreur"""
        self.animate_progress = False
        self.progress_bar.set(0)
        self.progress_var.set(f"❌ Erreur lors de {method_name}")
        self.status_label.configure(text="❌ Erreur")
        self.show_error(f"Erreur durant {method_name}:\n{error_msg}")
    
    def update_stats_display(self):
        """Met à jour l'affichage des statistiques"""
        self.stats_label.configure(
            text=f"Problèmes résolus: {self.stats['problems_solved']}\n"
                 f"Temps moyen: {self.stats['avg_solving_time']:.2f}s"
        )
    
    def display_results(self):
        """Affiche les résultats de la dernière résolution"""
        if not hasattr(self, 'last_result'):
            self.results_text.delete(0.0, tk.END)
            self.results_text.insert(0.0, "Aucun résultat à afficher.\nLancez d'abord une résolution.")
            return
        
        result = self.last_result
        
        # Titre avec informations
        title_text = f"📊 Résultats - {result['method']}\n"
        title_text += f"⏰ {result['timestamp'].strftime('%Y-%m-%d %H:%M:%S')}\n"
        title_text += f"⏱️ Temps d'exécution: {result.get('elapsed_time', 0):.2f}s\n"
        title_text += "="*60 + "\n\n"
        
        # Contenu dans l'onglet sortie détaillée
        self.results_text.delete(0.0, tk.END)
        self.results_text.insert(0.0, title_text + result['output'])
        
        # Créer le tableau final
        self.create_final_tableau_display()
        
        # Créer les graphiques
        self.create_result_graphs()
        
        # Créer le rapport
        self.create_result_report()
    
    def create_final_tableau_display(self):
        """Affiche le tableau final sous forme de table"""
        # Nettoyer le frame
        for widget in self.tableau_frame.winfo_children():
            widget.destroy()
        
        title = ctk.CTkLabel(
            self.tableau_frame,
            text="📊 Tableau Final du Simplexe",
            font=ctk.CTkFont(size=18, weight="bold")
        )
        title.pack(pady=(10, 20))
        
        # Extraire le tableau final depuis les résultats
        output = self.last_result.get('output', '')
        
        # Rechercher le tableau final dans la sortie
        if "Tableau final" in output or "Solution optimale" in output:
            # Créer une représentation visuelle du tableau
            table_frame = ctk.CTkFrame(self.tableau_frame, corner_radius=10)
            table_frame.pack(padx=20, pady=10)
            
            # Exemple de tableau (à adapter selon la sortie réelle)
            self.create_example_tableau(table_frame)
        else:
            no_table_label = ctk.CTkLabel(
                self.tableau_frame,
                text="Aucun tableau final disponible",
                font=ctk.CTkFont(size=14),
                text_color="gray"
            )
            no_table_label.pack(pady=50)
    
    def create_example_tableau(self, parent):
        """Crée un exemple de tableau visuel"""
        # Headers
        headers = ["Base", "x₁", "x₂", "s₁", "s₂", "s₃", "RHS"]
        
        # Créer le header
        header_frame = ctk.CTkFrame(parent)
        header_frame.pack(fill="x", padx=10, pady=(10, 0))
        
        for i, header in enumerate(headers):
            label = ctk.CTkLabel(
                header_frame,
                text=header,
                font=ctk.CTkFont(size=12, weight="bold"),
                width=80
            )
            label.grid(row=0, column=i, padx=5, pady=5)
        
        # Données exemple
        data = [
            ["s₁", "1", "0", "1", "0", "0", "4"],
            ["x₂", "0", "1", "0", "0.5", "0", "6"],
            ["s₃", "3", "0", "0", "-1", "1", "6"],
            ["Z", "-3", "0", "0", "2.5", "0", "30"]
        ]
        
        # Créer les lignes
        for row_idx, row_data in enumerate(data):
            row_frame = ctk.CTkFrame(parent, fg_color=("gray95", "gray15") if row_idx % 2 == 0 else "transparent")
            row_frame.pack(fill="x", padx=10)
            
            for col_idx, value in enumerate(row_data):
                if row_idx == len(data) - 1:  # Ligne Z
                    font = ctk.CTkFont(size=12, weight="bold")
                    text_color = "green" if col_idx == len(row_data) - 1 else None
                else:
                    font = ctk.CTkFont(size=12)
                    text_color = None
                
                label = ctk.CTkLabel(
                    row_frame,
                    text=value,
                    font=font,
                    text_color=text_color,
                    width=80
                )
                label.grid(row=0, column=col_idx, padx=5, pady=5)
    
    def create_result_graphs(self):
        """Crée les graphiques de résultats"""
        # Nettoyer le frame
        for widget in self.graphs_frame.winfo_children():
            widget.destroy()
        
        if self.current_problem["nombres_variables_base"] == 2:
            # Graphique 2D
            self.create_2d_solution_graph()
        elif self.current_problem["nombres_variables_base"] == 3:
            # Graphique 3D
            self.create_3d_solution_graph()
        else:
            # Graphique en barres pour plus de 3 variables
            self.create_bar_solution_graph()
    
    def create_2d_solution_graph(self):
        """Crée un graphique 2D de la solution"""
        fig, ax = plt.subplots(figsize=(8, 6))
        
        # Style selon le thème
        if self.theme.dark_mode:
            plt.style.use('dark_background')
        else:
            plt.style.use('default')
        
        # Tracer les contraintes
        self.plot_constraints(ax)
        
        # Ajouter la fonction objectif
        x = np.linspace(0, 20, 100)
        obj_coeffs = self.current_problem["tab_optimisation"][1:]
        if len(obj_coeffs) >= 2 and obj_coeffs[1] != 0:
            # Lignes d'iso-profit
            for z in [10, 20, 30, 40]:
                y = (z - obj_coeffs[0] * x) / obj_coeffs[1]
                ax.plot(x, y, '--', alpha=0.3, label=f'Z={z}')
        
        # Point optimal (simulé)
        ax.plot(6, 3, 'r*', markersize=20, label='Solution Optimale')
        ax.annotate('Optimal\n(6, 3)', xy=(6, 3), xytext=(7, 4),
                   arrowprops=dict(arrowstyle='->', color='red'))
        
        ax.set_xlim(0, 15)
        ax.set_ylim(0, 15)
        ax.set_xlabel('x₁', fontsize=14)
        ax.set_ylabel('x₂', fontsize=14)
        ax.set_title('Solution Graphique du Problème', fontsize=16, fontweight='bold')
        ax.grid(True, alpha=0.3)
        ax.legend()
        
        # Intégrer dans tkinter
        canvas = FigureCanvasTkAgg(fig, self.graphs_frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True, padx=10, pady=10)
        
        # Toolbar
        toolbar_frame = ctk.CTkFrame(self.graphs_frame)
        toolbar_frame.pack(fill="x", padx=10)
        toolbar = NavigationToolbar2Tk(canvas, toolbar_frame)
        toolbar.update()
    
    def create_3d_solution_graph(self):
        """Crée un graphique 3D de la solution"""
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')
        
        # Créer une grille pour la visualisation
        x = np.linspace(0, 10, 50)
        y = np.linspace(0, 10, 50)
        X, Y = np.meshgrid(x, y)
        
        # Fonction objectif
        obj_coeffs = self.current_problem["tab_optimisation"][1:]
        if len(obj_coeffs) >= 2:
            Z = obj_coeffs[0] * X + obj_coeffs[1] * Y
            
            # Surface de la fonction objectif
            surf = ax.plot_surface(X, Y, Z, alpha=0.3, cmap='viridis')
            
            # Point optimal (simulé)
            ax.scatter([5], [3], [obj_coeffs[0]*5 + obj_coeffs[1]*3], 
                      color='red', s=100, label='Solution Optimale')
        
        ax.set_xlabel('x₁')
        ax.set_ylabel('x₂')
        ax.set_zlabel('Z')
        ax.set_title('Visualisation 3D de la Solution')
        
        # Intégrer dans tkinter
        canvas = FigureCanvasTkAgg(fig, self.graphs_frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True, padx=10, pady=10)
    
    def create_bar_solution_graph(self):
        """Crée un graphique en barres pour la solution"""
        # Extraire les valeurs de la solution
        nb_vars = self.current_problem["nombres_variables_base"]
        
        # Valeurs simulées (à remplacer par les vraies valeurs extraites)
        variables = [f'x{self.subscript(i+1)}' for i in range(nb_vars)]
        values = np.random.uniform(0, 10, nb_vars)
        
        fig, ax = plt.subplots(figsize=(10, 6))
        
        # Style selon le thème
        if self.theme.dark_mode:
            plt.style.use('dark_background')
        
        # Créer le graphique en barres
        bars = ax.bar(variables, values, color=plt.cm.viridis(np.linspace(0, 1, nb_vars)))
        
        # Ajouter les valeurs sur les barres
        for bar, value in zip(bars, values):
            height = bar.get_height()
            ax.text(bar.get_x() + bar.get_width()/2., height,
                   f'{value:.2f}', ha='center', va='bottom')
        
        ax.set_xlabel('Variables', fontsize=14)
        ax.set_ylabel('Valeurs', fontsize=14)
        ax.set_title('Valeurs des Variables de Décision', fontsize=16, fontweight='bold')
        ax.grid(True, axis='y', alpha=0.3)
        
        # Intégrer dans tkinter
        canvas = FigureCanvasTkAgg(fig, self.graphs_frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True, padx=10, pady=10)
    
    def create_result_report(self):
        """Crée un rapport formaté des résultats"""
        # Nettoyer le frame
        for widget in self.report_frame.winfo_children():
            widget.destroy()
        
        # Titre du rapport
        title = ctk.CTkLabel(
            self.report_frame,
            text="📋 Rapport d'Analyse",
            font=ctk.CTkFont(size=20, weight="bold")
        )
        title.pack(pady=(10, 20))
        
        # Sections du rapport
        self.create_report_section("📊 Résumé Exécutif", self.get_executive_summary())
        self.create_report_section("🔍 Détails du Problème", self.get_problem_details())
        self.create_report_section("💡 Solution Optimale", self.get_optimal_solution())
        self.create_report_section("📈 Analyse de Sensibilité", self.get_sensitivity_analysis())
        self.create_report_section("💭 Recommandations", self.get_recommendations())
    
    def create_report_section(self, title, content):
        """Crée une section du rapport"""
        section_frame = ctk.CTkFrame(self.report_frame, corner_radius=10)
        section_frame.pack(fill="x", padx=20, pady=10)
        
        section_title = ctk.CTkLabel(
            section_frame,
            text=title,
            font=ctk.CTkFont(size=16, weight="bold")
        )
        section_title.pack(anchor="w", padx=15, pady=(10, 5))
        
        section_content = ctk.CTkLabel(
            section_frame,
            text=content,
            font=ctk.CTkFont(size=12),
            justify="left",
            anchor="w"
        )
        section_content.pack(anchor="w", padx=15, pady=(5, 15))
    
    def get_executive_summary(self):
        """Génère le résumé exécutif"""
        return f"""Le problème de programmation linéaire a été résolu avec succès.
Méthode utilisée: {self.last_result.get('method', 'N/A')}
Temps d'exécution: {self.last_result.get('elapsed_time', 0):.2f} secondes
Statut: Solution optimale trouvée"""
    
    def get_problem_details(self):
        """Génère les détails du problème"""
        nb_vars = self.current_problem["nombres_variables_base"]
        nb_constraints = self.current_problem["nb_equations"]
        obj_type = self.current_problem.get("objective_type", "max")
        
        return f"""Type d'optimisation: {obj_type.upper()}IMISATION
Nombre de variables de décision: {nb_vars}
Nombre de contraintes: {nb_constraints}
Méthode suggérée: {"Grand M" if any(c in [">=", "="] for c in self.current_problem.get("constraints_info", [])) else "Simplexe Standard"}"""
    
    def get_optimal_solution(self):
        """Extrait la solution optimale"""
        # Parser la sortie pour extraire la solution
        output = self.last_result.get('output', '')
        
        # Recherche basique de la valeur optimale
        if "Solution optimale" in output or "Z =" in output:
            return "Solution optimale trouvée (voir sortie détaillée)"
        else:
            return "Solution en cours d'extraction..."
    
    def get_sensitivity_analysis(self):
        """Génère l'analyse de sensibilité"""
        return """L'analyse de sensibilité permet d'évaluer l'impact des variations
des paramètres sur la solution optimale. Cette analyse est disponible
dans la méthode d'analyse duale."""
    
    def get_recommendations(self):
        """Génère des recommandations"""
        recommendations = []
        
        if self.current_problem["nombres_variables_base"] == 2:
            recommendations.append("• La visualisation graphique est disponible pour ce problème")
        
        if any(c in [">=", "="] for c in self.current_problem.get("constraints_info", [])):
            recommendations.append("• La méthode Grand M est recommandée pour ce type de contraintes")
        
        recommendations.append("• Considérez l'analyse duale pour une compréhension approfondie")
        recommendations.append("• Exportez les résultats en PDF pour vos rapports")
        
        return "\n".join(recommendations)
    
    def compare_methods(self):
        """Compare plusieurs méthodes avec une interface moderne"""
        if not self.current_problem:
            self.show_error("Veuillez d'abord définir un problème")
            return
        
        # Fenêtre de comparaison moderne
        compare_window = ctk.CTkToplevel(self.root)
        compare_window.title("⚖️ Comparaison des Méthodes")
        compare_window.geometry("1000x700")
        
        # Centrer la fenêtre
        compare_window.transient(self.root)
        compare_window.update_idletasks()
        x = (compare_window.winfo_screenwidth() // 2) - 500
        y = (compare_window.winfo_screenheight() // 2) - 350
        compare_window.geometry(f"1000x700+{x}+{y}")
        
        # Frame principal
        main_frame = ctk.CTkFrame(compare_window)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Titre
        title = ctk.CTkLabel(
            main_frame,
            text="⚖️ Comparaison des Méthodes de Résolution",
            font=ctk.CTkFont(size=24, weight="bold")
        )
        title.pack(pady=(0, 20))
        
        # Notebook pour les résultats
        comparison_notebook = ctk.CTkTabview(main_frame, corner_radius=10)
        comparison_notebook.pack(fill="both", expand=True, pady=(0, 20))
        
        # Onglets pour chaque méthode
        methods_data = [
            ("Simplexe Standard", self._solve_standard_worker),
            ("Grand M", self._solve_grand_m_worker),
            ("Analyse Duale", self._solve_dual_worker)
        ]
        
        # Dictionnaire pour stocker les résultats
        self.comparison_results = {}
        
        for method_name, worker in methods_data:
            comparison_notebook.add(method_name)
            tab = comparison_notebook.tab(method_name)
            
            # Zone de texte pour les résultats
            text_widget = ctk.CTkTextbox(
                tab,
                font=ctk.CTkFont(family="Consolas", size=11),
                corner_radius=10
            )
            text_widget.pack(fill="both", expand=True, padx=10, pady=10)
            
            # Frame pour les contrôles
            control_frame = ctk.CTkFrame(tab, fg_color="transparent")
            control_frame.pack(fill="x", padx=10, pady=(0, 10))
            
            # Bouton pour lancer cette méthode
            run_btn = AnimatedButton(
                control_frame,
                text=f"🚀 Lancer {method_name}",
                command=lambda m=method_name, w=worker, t=text_widget: self.run_comparison_method(m, w, t),
                width=200,
                height=35,
                corner_radius=8
            )
            run_btn.pack(side="left", padx=5)
            
            # Label de statut
            status_label = ctk.CTkLabel(
                control_frame,
                text="En attente...",
                font=ctk.CTkFont(size=12),
                text_color="gray"
            )
            status_label.pack(side="left", padx=20)
            
            # Stocker les widgets
            setattr(tab, 'text_widget', text_widget)
            setattr(tab, 'status_label', status_label)
        
        # Onglet de synthèse
        comparison_notebook.add("📊 Synthèse")
        synthesis_tab = comparison_notebook.tab("📊 Synthèse")
        self.create_synthesis_tab(synthesis_tab)
        
        # Boutons d'action
        actions_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        actions_frame.pack(fill="x")
        
        all_btn = AnimatedButton(
            actions_frame,
            text="🎯 Lancer Toutes les Méthodes",
            command=lambda: self.run_all_comparisons(comparison_notebook),
            width=250,
            height=40,
            corner_radius=10,
            fg_color="green"
        )
        all_btn.pack(side="left", padx=10)
        
        export_btn = AnimatedButton(
            actions_frame,
            text="📤 Exporter Comparaison",
            command=self.export_comparison,
            width=200,
            height=40,
            corner_radius=10
        )
        export_btn.pack(side="left", padx=10)
    
    def create_synthesis_tab(self, parent):
        """Crée l'onglet de synthèse de comparaison"""
        scroll_frame = ctk.CTkScrollableFrame(parent)
        scroll_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        self.synthesis_frame = scroll_frame
        
        # Titre
        title = ctk.CTkLabel(
            scroll_frame,
            text="📊 Synthèse Comparative",
            font=ctk.CTkFont(size=18, weight="bold")
        )
        title.pack(pady=(10, 20))
        
        # Message initial
        self.synthesis_message = ctk.CTkLabel(
            scroll_frame,
            text="Lancez les méthodes pour voir la comparaison",
            font=ctk.CTkFont(size=14),
            text_color="gray"
        )
        self.synthesis_message.pack(pady=50)
    
    def run_comparison_method(self, method_name, worker, text_widget):
        """Lance une méthode pour la comparaison"""
        text_widget.delete(0.0, tk.END)
        text_widget.insert(0.0, f"🔄 Lancement de {method_name}...\n\n")
        
        # Trouver le label de statut
        parent = text_widget.master
        if hasattr(parent, 'status_label'):
            parent.status_label.configure(text="🔄 En cours...", text_color="orange")
        
        try:
            import copy
            import time
            start_time = time.time()
            
            problem_copy = copy.deepcopy(self.current_problem)
            
            if method_name == "Simplexe Standard":
                solver = SimplexMethodTab(problem_copy)
                result = self.capture_solver_output(solver.run)
            elif method_name == "Grand M":
                solver = GrandMMethod(problem_copy)
                result = self.capture_solver_output(solver.run)
            elif method_name == "Analyse Duale":
                analyzer = DualMethod(problem_copy)
                result = self.capture_solver_output(analyzer.run_complete_analysis)
            
            elapsed_time = time.time() - start_time
            
            # Afficher les résultats
            text_widget.delete(0.0, tk.END)
            header = f"✅ {method_name} - Résultats (Temps: {elapsed_time:.2f}s)\n"
            header += "="*60 + "\n\n"
            text_widget.insert(0.0, header + result)
            
            # Mettre à jour le statut
            if hasattr(parent, 'status_label'):
                parent.status_label.configure(text=f"✅ Terminé ({elapsed_time:.2f}s)", text_color="green")
            
            # Stocker les résultats
            self.comparison_results[method_name] = {
                'output': result,
                'time': elapsed_time,
                'success': True
            }
            
            # Mettre à jour la synthèse
            self.update_synthesis()
            
        except Exception as e:
            text_widget.delete(0.0, tk.END)
            text_widget.insert(0.0, f"❌ Erreur {method_name}:\n{str(e)}")
            
            if hasattr(parent, 'status_label'):
                parent.status_label.configure(text="❌ Erreur", text_color="red")
            
            self.comparison_results[method_name] = {
                'output': str(e),
                'time': 0,
                'success': False
            }
    
    def run_all_comparisons(self, notebook):
        """Lance toutes les méthodes de comparaison"""
        methods = ["Simplexe Standard", "Grand M", "Analyse Duale"]
        
        for method in methods:
            # Trouver l'onglet
            tab = notebook.tab(method)
            if hasattr(tab, 'text_widget'):
                # Simuler le clic sur le bouton
                for child in tab.winfo_children():
                    if isinstance(child, ctk.CTkFrame):
                        for widget in child.winfo_children():
                            if isinstance(widget, AnimatedButton) and "Lancer" in widget.cget("text"):
                                widget.invoke()
                                break
    
    def update_synthesis(self):
        """Met à jour la synthèse comparative"""
        if not self.comparison_results:
            return
        
        # Nettoyer la synthèse
        for widget in self.synthesis_frame.winfo_children():
            if widget != self.synthesis_frame.winfo_children()[0]:  # Garder le titre
                widget.destroy()
        
        # Tableau comparatif
        table_frame = ctk.CTkFrame(self.synthesis_frame, corner_radius=10)
        table_frame.pack(fill="x", padx=20, pady=20)
        
        # Headers
        headers = ["Méthode", "Statut", "Temps (s)", "Itérations"]
        header_frame = ctk.CTkFrame(table_frame)
        header_frame.pack(fill="x", padx=10, pady=(10, 0))
        
        for i, header in enumerate(headers):
            label = ctk.CTkLabel(
                header_frame,
                text=header,
                font=ctk.CTkFont(size=14, weight="bold"),
                width=150
            )
            label.grid(row=0, column=i, padx=5, pady=5)
        
        # Données
        for row_idx, (method, data) in enumerate(self.comparison_results.items()):
            row_frame = ctk.CTkFrame(
                table_frame,
                fg_color=("gray95", "gray15") if row_idx % 2 == 0 else "transparent"
            )
            row_frame.pack(fill="x", padx=10)
            
            # Méthode
            ctk.CTkLabel(
                row_frame,
                text=method,
                font=ctk.CTkFont(size=12),
                width=150
            ).grid(row=0, column=0, padx=5, pady=5)
            
            # Statut
            status = "✅ Succès" if data['success'] else "❌ Erreur"
            status_color = "green" if data['success'] else "red"
            ctk.CTkLabel(
                row_frame,
                text=status,
                font=ctk.CTkFont(size=12),
                text_color=status_color,
                width=150
            ).grid(row=0, column=1, padx=5, pady=5)
            
            # Temps
            ctk.CTkLabel(
                row_frame,
                text=f"{data['time']:.3f}",
                font=ctk.CTkFont(size=12),
                width=150
            ).grid(row=0, column=2, padx=5, pady=5)
            
            # Itérations (à extraire de la sortie)
            iterations = self.extract_iterations(data['output'])
            ctk.CTkLabel(
                row_frame,
                text=str(iterations),
                font=ctk.CTkFont(size=12),
                width=150
            ).grid(row=0, column=3, padx=5, pady=5)
        
        # Graphique comparatif
        self.create_comparison_chart()
    
    def extract_iterations(self, output):
        """Extrait le nombre d'itérations de la sortie"""
        # Recherche basique du nombre d'itérations
        import re
        match = re.search(r'Itération[s]?\s*[:=]\s*(\d+)', output, re.IGNORECASE)
        if match:
            return int(match.group(1))
        return "N/A"
    
    def create_comparison_chart(self):
        """Crée un graphique comparatif"""
        if not self.comparison_results:
            return
        
        # Frame pour le graphique
        chart_frame = ctk.CTkFrame(self.synthesis_frame, corner_radius=10)
        chart_frame.pack(fill="x", padx=20, pady=20)
        
        chart_title = ctk.CTkLabel(
            chart_frame,
            text="📊 Comparaison des Temps d'Exécution",
            font=ctk.CTkFont(size=16, weight="bold")
        )
        chart_title.pack(pady=(10, 5))
        
        # Créer le graphique
        fig, ax = plt.subplots(figsize=(8, 4))
        
        methods = list(self.comparison_results.keys())
        times = [data['time'] for data in self.comparison_results.values()]
        colors = ['blue', 'green', 'orange']
        
        bars = ax.bar(methods, times, color=colors[:len(methods)])
        
        # Ajouter les valeurs sur les barres
        for bar, time in zip(bars, times):
            height = bar.get_height()
            ax.text(bar.get_x() + bar.get_width()/2., height,
                   f'{time:.3f}s', ha='center', va='bottom')
        
        ax.set_ylabel('Temps (secondes)')
        ax.set_title("Temps d'Exécution par Méthode")
        ax.grid(True, axis='y', alpha=0.3)
        
        # Intégrer dans tkinter
        canvas = FigureCanvasTkAgg(fig, chart_frame)
        canvas.draw()
        canvas.get_tk_widget().pack(padx=10, pady=10)
    
    def export_comparison(self):
        """Exporte la comparaison"""
        if not self.comparison_results:
            self.show_error("Aucune comparaison à exporter")
            return
        
        filename = filedialog.asksaveasfilename(
            title="Exporter la comparaison",
            defaultextension=".xlsx",
            filetypes=[("Excel", "*.xlsx"), ("CSV", "*.csv")]
        )
        
        if filename:
            # Créer un DataFrame pandas
            data = []
            for method, result in self.comparison_results.items():
                data.append({
                    'Méthode': method,
                    'Statut': 'Succès' if result['success'] else 'Erreur',
                    'Temps (s)': result['time'],
                    'Itérations': self.extract_iterations(result['output'])
                })
            
            df = pd.DataFrame(data)
            
            if filename.endswith('.xlsx'):
                df.to_excel(filename, index=False)
            else:
                df.to_csv(filename, index=False)
            
            self.show_success(f"✅ Comparaison exportée: {filename}")
    
    def new_problem(self):
        """Crée un nouveau problème"""
        if self.current_problem and messagebox.askyesno("Nouveau Problème", 
                                                        "Créer un nouveau problème?\n(Le problème actuel sera perdu)"):
            self.current_problem = None
            self.tabview.set("📝 Définition")
            self.show_success("✅ Prêt pour un nouveau problème!")
            self.update_solve_tab()
    
    def clear_problem(self):
        """Efface le problème actuel"""
        if messagebox.askyesno("Confirmation", "Effacer tous les champs ?"):
            self.current_problem = None
            # Réinitialiser les champs
            for widget in self.fields_frame.winfo_children():
                widget.destroy()
            self.show_success("✅ Champs effacés")
    
    def preview_problem(self):
        """Affiche un aperçu du problème avec style moderne"""
        if not self.current_problem:
            self.validate_problem()
        
        if self.current_problem:
            preview_window = ctk.CTkToplevel(self.root)
            preview_window.title("👁️ Aperçu du Problème")
            preview_window.geometry("700x500")
            preview_window.transient(self.root)
            
            # Frame principal
            main_frame = ctk.CTkFrame(preview_window)
            main_frame.pack(fill="both", expand=True, padx=20, pady=20)
            
            # Titre
            title = ctk.CTkLabel(
                main_frame,
                text="📋 Aperçu du Problème de Programmation Linéaire",
                font=ctk.CTkFont(size=18, weight="bold")
            )
            title.pack(pady=(0, 20))
            
            # Zone de texte
            text_widget = ctk.CTkTextbox(
                main_frame,
                font=ctk.CTkFont(family="Consolas", size=12),
                corner_radius=10
            )
            text_widget.pack(fill="both", expand=True, pady=(0, 20))
            
            # Générer et afficher le texte
            problem_text = self.generate_problem_text()
            text_widget.insert(0.0, problem_text)
            text_widget.configure(state="disabled")
            
            # Boutons
            buttons_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
            buttons_frame.pack(fill="x")
            
            copy_btn = AnimatedButton(
                buttons_frame,
                text="📋 Copier",
                command=lambda: self.copy_to_clipboard(problem_text),
                width=100,
                height=35,
                corner_radius=8
            )
            copy_btn.pack(side="left", padx=5)
            
            close_btn = AnimatedButton(
                buttons_frame,
                text="✅ Fermer",
                command=preview_window.destroy,
                width=100,
                height=35,
                corner_radius=8
            )
            close_btn.pack(side="right", padx=5)
    
    def copy_to_clipboard(self, text):
        """Copie le texte dans le presse-papier"""
        self.root.clipboard_clear()
        self.root.clipboard_append(text)
        self.show_success("✅ Copié dans le presse-papier!")
    
    def generate_problem_text(self):
        """Génère la représentation textuelle du problème"""
        if not self.current_problem:
            return "Aucun problème défini"
        
        text = []
        
        # Type d'optimisation
        obj_type = self.current_problem.get("objective_type", "max")
        text.append(f"{'='*50}\n")
        text.append(f"PROBLÈME DE PROGRAMMATION LINÉAIRE\n")
        text.append(f"{'='*50}\n\n")
        text.append(f"Type: {obj_type.upper()}IMISATION\n\n")
        
        # Fonction objectif
        text.append("FONCTION OBJECTIF:\n")
        coeffs = self.current_problem["tab_optimisation"][1:]
        text.append(f"{obj_type.upper()} Z = ")
        
        for i, c in enumerate(coeffs):
            display_c = c if obj_type == "max" else -c
            if i == 0:
                text.append(f"{display_c}x{self.subscript(1)}")
            else:
                sign = " + " if display_c >= 0 else " - "
                text.append(f"{sign}{abs(display_c)}x{self.subscript(i+1)}")
        
        text.append("\n\nCONTRAINTES:\n")
        
        # Contraintes
        equations = self.current_problem["equations"]
        constraints_info = self.current_problem.get("constraints_info", [])
        
        for i, (key, eq) in enumerate(equations.items()):
            text.append(f"  C{self.subscript(i+1)}: ")
            rhs = eq[0]
            coeffs = eq[1:]
            
            for j, c in enumerate(coeffs):
                if j == 0:
                    text.append(f"{c}x{self.subscript(1)}")
                else:
                    sign = " + " if c >= 0 else " - "
                    text.append(f"{sign}{abs(c)}x{self.subscript(j+1)}")
            
            constraint_type = constraints_info[i] if i < len(constraints_info) else "<="
            text.append(f" {constraint_type} {rhs}\n")
        
        text.append("\n  xⱼ ≥ 0 pour tout j\n\n")
        
        # Informations supplémentaires
        text.append("INFORMATIONS:\n")
        text.append(f"• Variables de décision: {self.current_problem['nombres_variables_base']}\n")
        text.append(f"• Contraintes: {self.current_problem['nb_equations']}\n")
        
        if constraints_info:
            has_eq = "=" in constraints_info
            has_geq = ">=" in constraints_info
            if has_eq or has_geq:
                text.append("• ⚠️ Méthode suggérée: Grand M\n")
            else:
                text.append("• ✅ Méthode suggérée: Simplexe Standard\n")
        
        return "".join(text)
    
    def save_problem(self):
        """Sauvegarde le problème actuel"""
        if not self.current_problem:
            self.show_error("Aucun problème à sauvegarder")
            return
        
        filename = filedialog.asksaveasfilename(
            title="Sauvegarder le problème",
            defaultextension=".json",
            filetypes=[("JSON", "*.json"), ("Tous les fichiers", "*.*")]
        )
        
        if filename:
            problem_data = {
                "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "method": "Interface Graphique",
                "variables": self.current_problem,
                "metadata": {
                    "nb_variables": self.current_problem.get("nombres_variables_base", 0),
                    "nb_contraintes": self.current_problem.get("nb_equations", 0),  
                    "constraints_types": self.current_problem.get("constraints_info", [])
                }
            }
            
            self.variable_manager.save_to_file(problem_data, filename)
            self.show_success(f"✅ Problème sauvegardé: {filename}")
    
    def load_problem(self):
        """Charge un problème depuis un fichier"""
        filename = filedialog.askopenfilename(
            title="Charger un problème",
            filetypes=[("JSON", "*.json"), ("Tous les fichiers", "*.*")]
        )
        
        if filename:
            variables = self.variable_manager.load_from_file(filename)
            if variables:
                self.current_problem = variables
                self.update_solve_tab()
                self.show_success(f"✅ Problème chargé: {filename}")
                self.tabview.set("🔍 Résolution")
    
    def load_examples(self):
        """Charge des exemples prédéfinis avec interface moderne"""
        examples_window = ctk.CTkToplevel(self.root)
        examples_window.title("🎯 Exemples Prédéfinis")
        examples_window.geometry("800x600")
        examples_window.transient(self.root)
        
        # Frame principal
        main_frame = ctk.CTkFrame(examples_window)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Titre
        title = ctk.CTkLabel(
            main_frame,
            text="🎯 Exemples de Problèmes Prédéfinis",
            font=ctk.CTkFont(size=20, weight="bold")
        )
        title.pack(pady=(0, 20))
        
        # Scrollable frame pour les exemples
        scroll_frame = ctk.CTkScrollableFrame(main_frame)
        scroll_frame.pack(fill="both", expand=True, pady=(0, 20))
        
        # Exemples
        examples = {
            "📊 Problème de Production": {
                "description": "Une usine produit 2 types de produits avec des contraintes de ressources",
                "details": "Max Z = 3x₁ + 5x₂\nContraintes: ressources limitées",
                "variables": {
                    "tab_optimisation": [0, 3, 5],
                    "nombres_variables_base": 2,
                    "equations": {
                        "equation_1": [4, 1, 0],
                        "equation_2": [12, 0, 2],
                        "equation_3": [18, 3, 2],
                    },
                    "nb_equations": 3,
                    "constraints_info": ["<=", "<=", "<="],
                    "objective_type": "max",
                    "method_type": "Exemple"
                },
                "color": "blue"
            },
            "🏭 Problème de Mélange": {
                "description": "Optimisation du mélange de matières premières",
                "details": "Min Z = 7x₁ + 6x₂ + 5x₃\nContraintes d'égalité",
                "variables": {
                    "tab_optimisation": [0, -7, -6, -5],
                    "nombres_variables_base": 3,
                    "equations": {
                        "equation_1": [18, 3, 8, 6],
                        "equation_2": [15, 1, 2, 6],
                    },
                    "nb_equations": 2,
                    "constraints_info": ["=", "="],
                    "objective_type": "min",
                    "method_type": "Exemple"
                },
                "color": "green"
            },
            "📦 Problème de Transport": {
                "description": "Minimisation des coûts de transport entre entrepôts",
                "details": "Min Z = 4x₁ + 3x₂ + 8x₃\nContraintes mixtes",
                "variables": {
                    "tab_optimisation": [0, -4, -3, -8],
                    "nombres_variables_base": 3,
                    "equations": {
                        "equation_1": [20, 2, 3, 1],
                        "equation_2": [15, 1, 1, 2],
                        "equation_3": [10, 1, 0, 1],
                    },
                    "nb_equations": 3,
                    "constraints_info": ["<=", ">=", "="],
                    "objective_type": "min",
                    "method_type": "Exemple"
                },
                "color": "orange"
            },
            "💰 Problème d'Investissement": {
                "description": "Maximisation du retour sur investissement",
                "details": "Max Z = 0.08x₁ + 0.12x₂ + 0.15x₃\nBudget limité",
                "variables": {
                    "tab_optimisation": [0, 0.08, 0.12, 0.15],
                    "nombres_variables_base": 3,
                    "equations": {
                        "equation_1": [100000, 1, 1, 1],
                        "equation_2": [30000, 1, 0, 0],
                        "equation_3": [50000, 0, 1, 0],
                    },
                    "nb_equations": 3,
                    "constraints_info": ["<=", ">=", "<="],
                    "objective_type": "max",
                    "method_type": "Exemple"
                },
                "color": "purple"
            }
        }
        
        # Créer les cartes d'exemples
        for name, data in examples.items():
            self.create_example_card(scroll_frame, name, data, examples_window)
        
        # Bouton fermer
        close_btn = AnimatedButton(
            main_frame,
            text="✅ Fermer",
            command=examples_window.destroy,
            width=150,
            height=40,
            corner_radius=10
        )
        close_btn.pack()
    
    def create_example_card(self, parent, name, data, window):
        """Crée une carte pour un exemple"""
        card = ctk.CTkFrame(parent, corner_radius=10)
        card.pack(fill="x", padx=10, pady=10)
        
        # Effet au survol
        card.bind("<Enter>", lambda e: card.configure(fg_color=("gray85", "gray25")))
        card.bind("<Leave>", lambda e: card.configure(fg_color=("gray90", "gray20")))
        
        # Contenu
        content_frame = ctk.CTkFrame(card, fg_color="transparent")
        content_frame.pack(fill="x", padx=20, pady=15)
        
        # Titre avec icône
        title_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        title_frame.pack(fill="x")
        
        title_label = ctk.CTkLabel(
            title_frame,
            text=name,
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color=data["color"]
        )
        title_label.pack(side="left")
        
        # Description
        desc_label = ctk.CTkLabel(
            content_frame,
            text=data["description"],
            font=ctk.CTkFont(size=12),
            text_color="gray"
        )
        desc_label.pack(anchor="w", pady=(5, 0))
        
        # Détails
        details_label = ctk.CTkLabel(
            content_frame,
            text=data["details"],
            font=ctk.CTkFont(family="Consolas", size=11),
            justify="left"
        )
        details_label.pack(anchor="w", pady=(5, 10))
        
        # Bouton charger
        load_btn = AnimatedButton(
            content_frame,
            text="📂 Charger cet exemple",
            command=lambda: self.load_example(data, window),
            width=200,
            height=35,
            corner_radius=8,
            fg_color=data["color"]
        )
        load_btn.pack(anchor="w")
    
    def load_example(self, example_data, window):
        """Charge un exemple spécifique"""
        self.current_problem = example_data["variables"]
        self.variable_manager.save_problem(self.current_problem, "Exemple Prédéfini")
        
        window.destroy()
        self.show_success("✅ Exemple chargé avec succès!")
        
        # Mettre à jour l'interface
        self.update_solve_tab()
        self.refresh_history_modern()
        self.tabview.set("🔍 Résolution")
    
    def save_results(self):
        """Sauvegarde les résultats"""
        if not hasattr(self, 'last_result'):
            self.show_error("Aucun résultat à sauvegarder")
            return
        
        filename = filedialog.asksaveasfilename(
            title="Sauvegarder les résultats",
            defaultextension=".txt",
            filetypes=[
                ("Fichier texte", "*.txt"),
                ("Markdown", "*.md"),
                ("Tous les fichiers", "*.*")
            ]
        )
        
        if filename:
            try:
                with open(filename, 'w', encoding='utf-8') as f:
                    result = self.last_result
                    f.write(f"Résultats - {result['method']}\n")
                    f.write(f"Timestamp: {result['timestamp']}\n")
                    f.write(f"Temps d'exécution: {result.get('elapsed_time', 0):.2f}s\n")
                    f.write("="*60 + "\n\n")
                    f.write(result['output'])
                
                self.show_success(f"✅ Résultats sauvegardés: {filename}")
            except Exception as e:
                self.show_error(f"Erreur lors de la sauvegarde: {e}")

def main():
    """Fonction principale pour lancer l'application"""
    root = ctk.CTk()
    app = SimplexGUI(root)
    
    # Gestion de la fermeture
    root.protocol("WM_DELETE_WINDOW", app.on_closing)
    
    # Lancement de l'application
    root.mainloop()

if __name__ == "__main__":
    main()// END OF FILE: gui.py

//---> PATH: /mnt/c/Users/Loic/Desktop/r/s2_moi/RO/TP2-simplex-tab-dual-grandM/main.py

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Lanceur Premium avec animations et effets visuels avancés
Version ultra-moderne pour le Solveur de Programmation Linéaire
"""

import tkinter as tk
from tkinter import ttk, messagebox, font
import math
import time
import threading
import random
from datetime import datetime
import os
import sys

class PremiumLauncher:
    """Lanceur premium avec animations sophistiquées"""
    
    def __init__(self):
        self.root = tk.Tk()
        self.setup_window()
        
        # Variables d'animation
        self.animation_running = True
        self.particles = []
        self.wave_offset = 0
        
        # Couleurs et thème
        self.theme = {
            'bg_gradient_start': '#0a0e27',
            'bg_gradient_end': '#1a1f3a',
            'accent': '#00d4ff',
            'accent_light': '#66e5ff',
            'success': '#00ff88',
            'warning': '#ffa500',
            'danger': '#ff4757',
            'text': '#ffffff',
            'text_dim': '#8892b0',
            'card_bg': 'rgba(26, 31, 58, 0.8)',
            'glow': '#00d4ff'
        }
        
        # Canvas principal pour les animations
        self.main_canvas = tk.Canvas(self.root, highlightthickness=0)
        self.main_canvas.pack(fill=tk.BOTH, expand=True)
        
        # Démarrer les animations de fond
        self.create_animated_background()
        
        # Créer l'interface
        self.create_premium_interface()
        
        # Lancer les animations
        self.animate_background()
        self.animate_particles()
        
    def setup_window(self):
        """Configure la fenêtre"""
        self.root.title("✨ Solveur Simplexe ")
        self.root.geometry("1000x700")
        self.root.minsize(900, 600)
        
        # Centrer la fenêtre
        self.root.update_idletasks()
        x = (self.root.winfo_screenwidth() // 2) - 500
        y = (self.root.winfo_screenheight() // 2) - 350
        self.root.geometry(f"1000x700+{x}+{y}")
        
        # Style sombre
        self.root.configure(bg='#0a0e27')
        
        # Fermeture propre
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
    
    def create_animated_background(self):
        """Crée un fond animé avec gradient et particules"""
        # Gradient de fond
        self.create_gradient()
        
        # Grille animée
        self.create_animated_grid()
        
        # Particules flottantes
        self.create_particles()
    
    def create_gradient(self):
        """Crée un gradient de fond"""
        width = 1000
        height = 700
        
        # Créer le gradient vertical
        for i in range(height):
            # Interpolation des couleurs
            ratio = i / height
            r1, g1, b1 = int('0a', 16), int('0e', 16), int('27', 16)
            r2, g2, b2 = int('1a', 16), int('1f', 16), int('3a', 16)
            
            r = int(r1 + (r2 - r1) * ratio)
            g = int(g1 + (g2 - g1) * ratio)
            b = int(b1 + (b2 - b1) * ratio)
            
            color = f'#{r:02x}{g:02x}{b:02x}'
            self.main_canvas.create_line(0, i, width, i, fill=color, width=1)
    
    def create_animated_grid(self):
        """Crée une grille animée en arrière-plan"""
        self.grid_lines = []
        
        # Lignes verticales
        for x in range(0, 1000, 50):
            line = self.main_canvas.create_line(x, 0, x, 700, 
                                               fill='#1a2545', width=1)
            self.grid_lines.append(line)
        
        # Lignes horizontales
        for y in range(0, 700, 50):
            line = self.main_canvas.create_line(0, y, 1000, y,
                                               fill='#1a2545', width=1)
            self.grid_lines.append(line)
    
    def create_particles(self):
        """Crée des particules flottantes"""
        for _ in range(30):
            x = random.randint(0, 1000)
            y = random.randint(0, 700)
            size = random.randint(2, 4)
            speed = random.uniform(0.5, 2)
            
            particle = {
                'id': self.main_canvas.create_oval(x-size, y-size, x+size, y+size,
                                                  fill=self.theme['accent_light'],
                                                  outline=''),
                'x': x,
                'y': y,
                'size': size,
                'speed': speed,
                'opacity': random.uniform(0.3, 0.8)
            }
            self.particles.append(particle)
    
    def animate_background(self):
        """Anime le fond (grille avec effet de vague)"""
        if not self.animation_running:
            return
        
        self.wave_offset += 0.1
        
        # Animer la grille avec effet de vague
        for i, line in enumerate(self.grid_lines):
            coords = self.main_canvas.coords(line)
            if len(coords) == 4:
                # Déterminer si c'est une ligne verticale ou horizontale
                if coords[0] == coords[2]:  # Verticale
                    wave = math.sin(self.wave_offset + i * 0.1) * 5
                    self.main_canvas.coords(line, coords[0] + wave, coords[1], 
                                          coords[2] + wave, coords[3])
        
        self.root.after(50, self.animate_background)
    
    def animate_particles(self):
        """Anime les particules flottantes"""
        if not self.animation_running:
            return
        
        for particle in self.particles:
            # Mouvement vertical
            particle['y'] -= particle['speed']
            
            # Réinitialiser si sort de l'écran
            if particle['y'] < -10:
                particle['y'] = 710
                particle['x'] = random.randint(0, 1000)
            
            # Mouvement sinusoïdal horizontal
            wave_x = math.sin(particle['y'] * 0.01) * 20
            
            # Mettre à jour la position
            self.main_canvas.coords(particle['id'],
                                   particle['x'] + wave_x - particle['size'],
                                   particle['y'] - particle['size'],
                                   particle['x'] + wave_x + particle['size'],
                                   particle['y'] + particle['size'])
        
        self.root.after(30, self.animate_particles)
    
    def create_premium_interface(self):
        """Crée l'interface principale"""
        # Container principal flottant
        self.container = tk.Frame(self.main_canvas, bg='#1a1f3a', bd=0)
        self.container.place(relx=0.5, rely=0.5, anchor='center', width=800, height=500)
        
        # Effet d'ombre
        self.create_shadow_effect(self.container)
        
        # En-tête animé
        self.create_animated_header()
        
        # Zone de contenu principal
        self.content_area = tk.Frame(self.container, bg='#1a1f3a')
        self.content_area.pack(fill=tk.BOTH, expand=True, padx=40, pady=(20, 40))
        
        # Créer l'écran de démarrage
        self.show_splash_screen()
        
        # Transition vers l'interface principale après 3 secondes
        self.root.after(3000, self.show_main_interface)
    
    def create_shadow_effect(self, widget):
        """Crée un effet d'ombre pour les widgets"""
        # Créer plusieurs rectangles décalés pour l'effet d'ombre
        for i in range(5):
            offset = i * 2
            color = f'#{int(10 + i*2):02x}{int(14 + i*2):02x}{int(39 + i*2):02x}'
            shadow = tk.Frame(self.main_canvas, bg=color, bd=0)
            shadow.place(in_=widget, x=offset, y=offset, relwidth=1, relheight=1)
            shadow.lower()
    
    def create_animated_header(self):
        """Crée un en-tête avec animation de texte"""
        self.header_frame = tk.Frame(self.container, bg='#0f1629', height=100)
        self.header_frame.pack(fill=tk.X)
        self.header_frame.pack_propagate(False)
        
        # Canvas pour l'animation du titre
        self.title_canvas = tk.Canvas(self.header_frame, bg='#0f1629', 
                                     highlightthickness=0, height=100)
        self.title_canvas.pack(fill=tk.BOTH, expand=True)
        
        # Titre avec effet de lueur
        self.title_text = self.title_canvas.create_text(400, 50,
                                                        text="SOLVEUR SIMPLEXE",
                                                        font=('Arial', 28, 'bold'),
                                                        fill=self.theme['accent'])
        
        # Ligne décorative animée
        self.deco_line = self.title_canvas.create_rectangle(200, 80, 600, 82,
                                                           fill=self.theme['accent'],
                                                           outline='')
        
        # Lancer l'animation du titre
        self.animate_title()
    
    def animate_title(self):
        """Anime le titre avec effet de lueur pulsante"""
        # Effet de pulsation
        self.title_glow_phase = getattr(self, 'title_glow_phase', 0)
        self.title_glow_phase += 0.1
        
        # Calculer l'intensité de la lueur
        glow_intensity = (math.sin(self.title_glow_phase) + 1) / 2
        
        # Créer l'effet de lueur avec plusieurs textes superposés
        for i in range(3):
            offset = i * 2
            opacity = int(255 * glow_intensity * (1 - i/3))
            color = f'#{opacity:02x}d4ff'
            
            # Créer ou mettre à jour le texte de lueur
            glow_id = getattr(self, f'title_glow_{i}', None)
            if glow_id:
                self.title_canvas.itemconfig(glow_id, fill=color)
            else:
                glow = self.title_canvas.create_text(400 + offset, 50 + offset,
                                                    text="SOLVEUR SIMPLEXE",
                                                    font=('Arial', 28, 'bold'),
                                                    fill=color)
                self.title_canvas.tag_lower(glow, self.title_text)
                setattr(self, f'title_glow_{i}', glow)
        
        # Animer la ligne décorative
        line_width = 200 + 200 * glow_intensity
        self.title_canvas.coords(self.deco_line, 400 - line_width/2, 80,
                                400 + line_width/2, 82)
        
        if self.animation_running:
            self.root.after(50, self.animate_title)
    
    def show_splash_screen(self):
        """Affiche l'écran de démarrage animé"""
        self.splash_frame = tk.Frame(self.content_area, bg='#1a1f3a')
        self.splash_frame.pack(fill=tk.BOTH, expand=True)
        
        # Logo animé (simulation)
        logo_canvas = tk.Canvas(self.splash_frame, bg='#1a1f3a', 
                               highlightthickness=0, width=200, height=200)
        logo_canvas.pack(pady=50)
        
        # Créer un logo animé avec des cercles concentriques
        self.logo_circles = []
        colors = ['#00d4ff', '#00a8cc', '#008099', '#005866']
        for i, color in enumerate(colors):
            size = 100 - i*20
            circle = logo_canvas.create_oval(100-size, 100-size, 100+size, 100+size,
                                           outline=color, width=3)
            self.logo_circles.append(circle)
        
        # Texte de chargement
        self.loading_text = tk.Label(self.splash_frame,
                                    text="Initialisation du système...",
                                    font=('Arial', 14),
                                    fg=self.theme['text_dim'],
                                    bg='#1a1f3a')
        self.loading_text.pack()
        
        # Barre de progression stylisée
        self.create_stylized_progress_bar()
        
        # Animer le logo
        self.animate_logo()
    
    def create_stylized_progress_bar(self):
        """Crée une barre de progression personnalisée"""
        progress_frame = tk.Frame(self.splash_frame, bg='#1a1f3a')
        progress_frame.pack(pady=20)
        
        # Canvas pour la barre de progression
        self.progress_canvas = tk.Canvas(progress_frame, width=400, height=10,
                                        bg='#0f1629', highlightthickness=0)
        self.progress_canvas.pack()
        
        # Fond de la barre
        self.progress_canvas.create_rectangle(0, 0, 400, 10, fill='#0f1629', outline='')
        
        # Barre de progression avec gradient
        self.progress_bar = self.progress_canvas.create_rectangle(0, 0, 0, 10,
                                                                 fill=self.theme['accent'],
                                                                 outline='')
        
        # Particules sur la barre
        self.progress_particles = []
        
        # Animer la progression
        self.animate_progress()
    
    def animate_logo(self):
        """Anime le logo de démarrage"""
        if not hasattr(self, 'logo_rotation'):
            self.logo_rotation = 0
        
        self.logo_rotation += 2
        
        # Faire tourner les cercles
        for i, circle in enumerate(self.logo_circles):
            # Rotation différente pour chaque cercle
            angle = self.logo_rotation * (1 + i * 0.2)
            # Effet de respiration
            scale = 1 + 0.1 * math.sin(angle * 0.05)
            size = (100 - i*20) * scale
            
            # Mettre à jour la position
            logo_canvas = self.splash_frame.winfo_children()[0]
            logo_canvas.coords(circle, 100-size, 100-size, 100+size, 100+size)
        
        if self.animation_running and hasattr(self, 'splash_frame'):
            self.root.after(30, self.animate_logo)
    
    def animate_progress(self):
        """Anime la barre de progression"""
        if not hasattr(self, 'progress_value'):
            self.progress_value = 0
        
        if self.progress_value < 400:
            self.progress_value += 4
            self.progress_canvas.coords(self.progress_bar, 0, 0, self.progress_value, 10)
            
            # Ajouter des particules
            if random.random() > 0.7:
                particle = self.progress_canvas.create_oval(
                    self.progress_value-2, 3, self.progress_value+2, 7,
                    fill=self.theme['accent_light'], outline=''
                )
                self.progress_particles.append({
                    'id': particle,
                    'x': self.progress_value,
                    'speed': random.uniform(2, 5)
                })
            
            # Animer les particules existantes
            for particle in self.progress_particles[:]:
                particle['x'] += particle['speed']
                self.progress_canvas.coords(particle['id'],
                                          particle['x']-2, 3,
                                          particle['x']+2, 7)
                
                # Supprimer si hors écran
                if particle['x'] > 420:
                    self.progress_canvas.delete(particle['id'])
                    self.progress_particles.remove(particle)
            
            self.root.after(20, self.animate_progress)
    
    def show_main_interface(self):
        """Affiche l'interface principale après le splash"""
        # Fade out du splash screen
        if hasattr(self, 'splash_frame'):
            self.splash_frame.destroy()
        
        # Créer l'interface principale
        self.main_frame = tk.Frame(self.content_area, bg='#1a1f3a')
        self.main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Cartes d'action avec effet hover
        self.create_action_cards()
        
        # Zone de statut
        self.create_status_zone()
        
        # Vérifier les dépendances
        self.check_dependencies_animated()
    
    def create_action_cards(self):
        """Crée des cartes d'action interactives"""
        cards_frame = tk.Frame(self.main_frame, bg='#1a1f3a')
        cards_frame.pack(fill=tk.BOTH, expand=True, pady=20)
        
        # Configuration des cartes
        cards_config = [
            {
                'title': '🚀 LANCER',
                'subtitle': 'Démarrer l\'application',
                'color': self.theme['success'],
                'command': self.launch_application
            },
            {
                'title': '📦 INSTALLER',
                'subtitle': 'Gérer les dépendances',
                'color': self.theme['warning'],
                'command': self.show_dependencies
            },
            {
                'title': '📚 AIDE',
                'subtitle': 'Documentation',
                'color': self.theme['accent'],
                'command': self.show_help
            }
        ]
        
        # Créer les cartes
        for i, config in enumerate(cards_config):
            card = self.create_interactive_card(cards_frame, config)
            card.grid(row=0, column=i, padx=20, pady=10, sticky='nsew')
            
        # Configuration du grid
        cards_frame.grid_columnconfigure(0, weight=1)
        cards_frame.grid_columnconfigure(1, weight=1)
        cards_frame.grid_columnconfigure(2, weight=1)
    
    def create_interactive_card(self, parent, config):
        """Crée une carte interactive avec animations"""
        # Frame de la carte
        card = tk.Frame(parent, bg='#252b48', bd=0, cursor='hand2')
        
        # Canvas pour les effets
        canvas = tk.Canvas(card, highlightthickness=0, bg='#252b48')
        canvas.pack(fill=tk.BOTH, expand=True)
        
        # Taille de la carte
        card_width = 200
        card_height = 150
        canvas.config(width=card_width, height=card_height)
        
        # Fond avec bordure
        bg_rect = canvas.create_rectangle(2, 2, card_width-2, card_height-2,
                                         fill='#252b48', outline=config['color'], width=2)
        
        # Titre
        title = canvas.create_text(card_width//2, 50,
                                  text=config['title'],
                                  font=('Arial', 18, 'bold'),
                                  fill=config['color'])
        
        # Sous-titre
        subtitle = canvas.create_text(card_width//2, 80,
                                     text=config['subtitle'],
                                     font=('Arial', 10),
                                     fill=self.theme['text_dim'])
        
        # Effet hover
        def on_enter(e):
            canvas.itemconfig(bg_rect, fill='#2d3454')
            canvas.itemconfig(title, font=('Arial', 20, 'bold'))
            
            # Effet de lueur
            for i in range(3):
                glow = canvas.create_rectangle(2-i*2, 2-i*2, 
                                             card_width-2+i*2, card_height-2+i*2,
                                             outline=config['color'], width=1)
                canvas.tag_lower(glow, bg_rect)
                canvas.after(100, lambda g=glow: canvas.delete(g))
        
        def on_leave(e):
            canvas.itemconfig(bg_rect, fill='#252b48')
            canvas.itemconfig(title, font=('Arial', 18, 'bold'))
        
        def on_click(e):
            # Animation de clic
            canvas.move(bg_rect, 2, 2)
            canvas.move(title, 2, 2)
            canvas.move(subtitle, 2, 2)
            canvas.after(100, lambda: [
                canvas.move(bg_rect, -2, -2),
                canvas.move(title, -2, -2),
                canvas.move(subtitle, -2, -2)
            ])
            
            # Exécuter la commande
            if config['command']:
                self.root.after(150, config['command'])
        
        # Lier les événements
        canvas.bind('<Enter>', on_enter)
        canvas.bind('<Leave>', on_leave)
        canvas.bind('<Button-1>', on_click)
        
        return card
    
    def create_status_zone(self):
        """Crée la zone de statut avec indicateurs animés"""
        status_frame = tk.Frame(self.main_frame, bg='#0f1629', height=100)
        status_frame.pack(fill=tk.X, side='bottom')
        status_frame.pack_propagate(False)
        
        # Canvas pour les animations de statut
        self.status_canvas = tk.Canvas(status_frame, bg='#0f1629',
                                      highlightthickness=0)
        self.status_canvas.pack(fill=tk.BOTH, expand=True)
        
        # Texte de statut
        self.status_text = self.status_canvas.create_text(400, 30,
                                                         text="Vérification du système...",
                                                         font=('Arial', 12),
                                                         fill=self.theme['text_dim'])
        
        # Indicateurs de statut
        self.status_indicators = []
        indicators = ['Python', 'Modules', 'Interface']
        
        for i, name in enumerate(indicators):
            x = 250 + i * 150
            
            # Cercle indicateur
            indicator = self.status_canvas.create_oval(x-10, 50, x+10, 70,
                                                     fill='#1a2545', outline='')
            
            # Texte
            text = self.status_canvas.create_text(x+30, 60,
                                                text=name,
                                                font=('Arial', 10),
                                                fill=self.theme['text_dim'],
                                                anchor='w')
            
            self.status_indicators.append({'circle': indicator, 'text': text, 'status': 'checking'})
        
        # Animer les indicateurs
        self.animate_status_indicators()
    
    def animate_status_indicators(self):
        """Anime les indicateurs de statut"""
        for i, indicator in enumerate(self.status_indicators):
            if indicator['status'] == 'checking':
                # Animation de vérification (pulsation)
                phase = time.time() * 2 + i * 0.5
                intensity = (math.sin(phase) + 1) / 2
                color = f'#{int(0 + 212*intensity):02x}{int(212 + 43*intensity):02x}ff'
                self.status_canvas.itemconfig(indicator['circle'], fill=color)
        
        if self.animation_running:
            self.root.after(50, self.animate_status_indicators)
    
    def check_dependencies_animated(self):
        """Vérifie les dépendances avec animation"""
        def check():
            # Simuler la vérification
            time.sleep(1)
            
            # Python OK
            self.status_indicators[0]['status'] = 'ok'
            self.status_canvas.itemconfig(self.status_indicators[0]['circle'], 
                                        fill=self.theme['success'])
            
            time.sleep(0.5)
            
            # Modules OK
            self.status_indicators[1]['status'] = 'ok'
            self.status_canvas.itemconfig(self.status_indicators[1]['circle'],
                                        fill=self.theme['success'])
            
            time.sleep(0.5)
            
            # Interface OK
            self.status_indicators[2]['status'] = 'ok'
            self.status_canvas.itemconfig(self.status_indicators[2]['circle'],
                                        fill=self.theme['success'])
            
            # Mettre à jour le statut
            self.status_canvas.itemconfig(self.status_text,
                                        text="✅ Système prêt - Toutes les dépendances sont installées",
                                        fill=self.theme['success'])
        
        # Lancer dans un thread
        thread = threading.Thread(target=check)
        thread.daemon = True
        thread.start()
    
    def launch_application(self):
        """Lance l'application avec effet de transition"""
        # Créer un overlay de transition
        overlay = tk.Frame(self.root, bg='#0a0e27')
        overlay.place(x=0, y=0, relwidth=1, relheight=1)
        
        # Texte de transition
        loading_label = tk.Label(overlay,
                               text="Lancement en cours...",
                               font=('Arial', 24, 'bold'),
                               fg=self.theme['accent'],
                               bg='#0a0e27')
        loading_label.place(relx=0.5, rely=0.5, anchor='center')
        
        # Animation de fondu
        def fade_in(alpha=0):
            if alpha < 1:
                overlay.place(x=0, y=0, relwidth=1, relheight=1)
                self.root.after(20, lambda: fade_in(alpha + 0.05))
            else:
                # Lancer l'application
                try:
                    from gui import main
                    self.animation_running = False
                    self.root.destroy()
                    main()
                except Exception as e:
                    overlay.destroy()
                    messagebox.showerror("Erreur", f"Impossible de lancer l'application:\n{e}")
        
        fade_in()
    
    def show_dependencies(self):
        """Affiche la gestion des dépendances"""
        messagebox.showinfo("Dépendances", "Gestionnaire de dépendances\n\nToutes les dépendances sont installées!")
    
    def show_help(self):
        """Affiche l'aide"""
        messagebox.showinfo("Aide", "Solveur Simplexe \n\nInterface moderne pour l'optimisation linéaire")
    
    def on_closing(self):
        """Gestion de la fermeture"""
        self.animation_running = False
        self.root.destroy()
    
    def run(self):
        """Lance l'application"""
        self.root.mainloop()


def main():
    """Point d'entrée principal"""
    app = PremiumLauncher()
    app.run()


if __name__ == "__main__":
    main()// END OF FILE: main.py

//---> PATH: /mnt/c/Users/Loic/Desktop/r/s2_moi/RO/TP2-simplex-tab-dual-grandM/setup.py

# setup.py
from cx_Freeze import setup, Executable
import sys

# Dépendances
build_exe_options = {
    "packages": ["tkinter", "matplotlib", "numpy", "colorama", "tabulate"],
    "include_files": [
        "tab_method.py",
        "variables.py",
        "grand_M_method.py",
        "dual_method.py",
        "enhanced_variables.py",
        "gui.py"
    ],
    "excludes": ["test", "unittest"],
}

# Base pour Windows GUI
base = None
if sys.platform == "win32":
    base = "Win32GUI"

setup(
    name="SimplexSolver",
    version="2.0",
    description="Solveur de Programmation Linéaire",
    options={"build_exe": build_exe_options},
    executables=[
        Executable(
            "main.py",
            base=base,
            icon="icon.ico",
            target_name="SimplexSolver_1.exe"
        )
    ]
)// END OF FILE: setup.py

//---> PATH: /mnt/c/Users/Loic/Desktop/r/s2_moi/RO/TP2-simplex-tab-dual-grandM/stats.json

{"problems_solved": 0, "total_iterations": 0, "avg_solving_time": 0, "methods_used": {"Simplexe": 0, "Grand M": 0, "Dual": 0}}// END OF FILE: stats.json

//---> PATH: /mnt/c/Users/Loic/Desktop/r/s2_moi/RO/TP2-simplex-tab-dual-grandM/tab_method.py

from variables import display_simplex_tableau

class SimplexMethodTab:
    def __init__(self, variables:dict):
        self.variables = variables
        self.n = variables["nombres_variables_base"]
        
    def run(self):
        self.add_ecart_variables()
        self.variables["tab_optimisation"] = [-x for x in self.variables["tab_optimisation"]]
        iteration = 0
        while self.can_iterate():
            iteration += 1
            print(f"\n===== Itération {iteration} =====")
            col = self.find_pivot_column()
            pivot = self.row_pivot(col)
            print(f"colonne pivot : {col}")
            print(f"ligne pivot : {pivot}")
            self.new_tableau(pivot, col)
            display_simplex_tableau(self.variables, iteration)
        self.display_results()
        
    def find_pivot_column(self):
        min_val = min(self.variables["tab_optimisation"][1:])
        if min_val >= 0:
            return -1 
        return self.variables["tab_optimisation"][1:].index(min_val) + 1
    
    def new_tableau(self, pivot:int, col:int)->None:
        equations = list(self.variables["equations"].values())
        tab_optimisation = self.variables["tab_optimisation"].copy()
        equations[pivot] = [x / equations[pivot][col] for x in equations[pivot]]
        for i in range(len(equations)):
            if i != pivot:
                equations[i] = [x - (equations[i][col] * equations[pivot][j]) for j, x in enumerate(equations[i])]
        tab_optimisation = [x - (tab_optimisation[col] * equations[pivot][j])  for j, x in enumerate(tab_optimisation)]
        self.variables["tab_optimisation"] = tab_optimisation
        for k, equation in enumerate(equations):
            self.variables["equations"][list(self.variables["equations"].keys())[k]] = equation
        return None
    
    def maximum(self, table:list)->int:
        abs_tab = [abs(x) for x in table]
        return abs_tab.index(max(abs_tab))
    
    def row_pivot(self,col):
        temp = []
        for row in self.variables["equations"].values():
            if row[col] > 0:
                temp.append(row[0] / row[col])
            else:
                temp.append(float('inf'))

        return temp.index(min(temp))
    
    def add_ecart_variables(self)->None:
        equations = list(self.variables["equations"].values())
        for _ in range(len(equations)):
            self.variables["tab_optimisation"].append(0)
            
        for i, equation in enumerate(equations):
            init_len = len(equations[i])
            for k in range(len(equations[i]), self.variables["nombres_variables_base"] + self.variables["nb_equations"]+1):
                if len(equations[i]) == init_len+i:
                    equations[i].append(1)
                else:
                    equations[i].append(0)
        for k, equation in enumerate(equations):
            self.variables["equations"][list(self.variables["equations"].keys())[k]] = equation
        return
    
    def can_iterate(self)->bool:
        for value in self.variables["tab_optimisation"][1:]:
            if value < 0:
                return True
        return False
    
    def ajout_variables_ecart(self):
        if(self.n >=len(self.variables['equations'])):
            # je dois completer les equations par les variables
            pass
        pass
    
    
    
    def display_results(self):
        print("\n===== Solution Optimale =====")
        z_opt = self.variables["tab_optimisation"][0]
        print(f"Valeur optimale: {z_opt}")
        
        var_values = [0] * (self.variables["nombres_variables_base"])
        # On cherche les colonnes qui ont exactement un '1' et le reste des '0'
        for j in range(1, self.variables["nombres_variables_base"] + 1):
            ones_count = 0
            one_position = -1
            for i, eq in enumerate(self.variables["equations"].values()):
                if abs(eq[j] - 1.0) < 1e-10:
                    ones_count += 1
                    one_position = i
                elif abs(eq[j]) > 1e-10:
                    ones_count = 0
                    break
            
            if ones_count == 1:
                var_values[j-1] = list(self.variables["equations"].values())[one_position][0]
        for i, val in enumerate(var_values):
            print(f"x{i+1} = {val}")
        
if __name__ == "__main__":
    variables = {
        "tab_optimisation": [0, 45, 55],
        "nombres_variables_base": 2,
        "equations": {
            "equation_1": [120, 6,4],
            "equation_2": [180,  3,10],
        },
        "nb_equations": 2
    }
    simplex = SimplexMethodTab(variables)
    simplex.run()// END OF FILE: tab_method.py

//---> PATH: /mnt/c/Users/Loic/Desktop/r/s2_moi/RO/TP2-simplex-tab-dual-grandM/tests/test_simplex_solver.py

# Fichier : test_simplex_solver.py (Concept)
import unittest
# Supposons que tes classes et fonctions sont importables
# from tab_method import SimplexMethodTab 
# from grand_M_method import GrandMMethod
# from tes_fonctions_utiles import preparer_probleme_standard 

# Pour cet exemple, nous allons simuler les classes pour les tests
class MockSimplexMethodTab:
    def __init__(self, variables):
        self.variables = variables
        self.solution_optimale_connue_z = 0
        self.solution_optimale_connue_vars = {}

    def run(self):
        # Simuler la résolution. Dans un vrai test, cela exécuterait l'algo.
        # Pour l'exemple, on affecte une solution connue si le problème correspond.
        if self.variables.get("test_case_name") == "simple_max_problem":
            self.variables["tab_optimisation"][0] = 36.0 # Z optimal
            # Simuler les valeurs des variables de base dans le tableau final
            # Exemple: x2=6, x1=2 (si s1, s2, s3 sont les écarts)
            # self.variables["equations"]["equation_1"][0] = 2 # x1
            # self.variables["equations"]["equation_2"][0] = 6 # x2
            # ... (ceci est une simplification extrême)
            # En réalité, on vérifierait les valeurs dans le tableau final.
            self.solution_optimale_connue_z = 36.0
            self.solution_optimale_connue_vars = {"x1": 2.0, "x2": 6.0} 
            print("MockSimplexMethodTab: Simulation de la résolution pour 'simple_max_problem'")
        else:
            print(f"MockSimplexMethodTab: Pas de solution simulée pour {self.variables.get('test_case_name')}")


    def get_optimal_z(self):
        return self.variables["tab_optimisation"][0]

    def get_optimal_variable_values(self):
        # Ceci est une simplification. Il faudrait extraire les valeurs
        # des variables de base du tableau final, comme dans ta fonction display_results.
        # Pour le test, on va tricher un peu.
        return self.solution_optimale_connue_vars


class TestSimplexSolvers(unittest.TestCase):

    def test_simple_maximization_problem(self):
        # Problème classique: Max Z = 3x1 + 5x2
        # x1 <= 4
        # 2x2 <= 12
        # 3x1 + 2x2 <= 18
        # Solution connue: Z=36, x1=2, x2=6
        
        test_vars = {
            "test_case_name": "simple_max_problem",
            "tab_optimisation": [0, 3, 5], # En interne, on maximise -(-3x1 -5x2)
            "nombres_variables_base": 2,
            "equations": {
                "equation_1": [4, 1, 0],
                "equation_2": [12, 0, 2],
                "equation_3": [18, 3, 2],
            },
            "nb_equations": 3,
            # "constraints_info" est important pour GrandM et DeuxPhases
        }
        
        # Ici, on utilise le Mock pour l'exemple. Dans ton cas, tu utiliserais:
        # solver = SimplexMethodTab(test_vars)
        solver = MockSimplexMethodTab(test_vars) 
        solver.run() # Exécute l'algorithme
        
        optimal_z = solver.get_optimal_z()
        optimal_vars = solver.get_optimal_variable_values()
        
        self.assertAlmostEqual(optimal_z, 36.0, places=5, msg="La valeur Z optimale est incorrecte.")
        self.assertAlmostEqual(optimal_vars.get("x1", 0), 2.0, places=5, msg="La valeur de x1 est incorrecte.")
        self.assertAlmostEqual(optimal_vars.get("x2", 0), 6.0, places=5, msg="La valeur de x2 est incorrecte.")


if __name__ == '__main__':
    unittest.main()// END OF FILE: tests/test_simplex_solver.py

//---> PATH: /mnt/c/Users/Loic/Desktop/r/s2_moi/RO/TP2-simplex-tab-dual-grandM/variables.py

from tabulate import tabulate
from colorama import init, Fore, Style

# Initialiser colorama pour les couleurs dans le terminal
init()

def tab_var(nombres_variables_base: int, nb_equations: int) -> dict:
    """
    This function returns a list of tab variables.
    :param nombres_variables_base: number of variables
    :param nb_equations: l'equation a combien d'equations principales
    :return: a dictionary with the list of variables and the number of variables
    """
    print(Fore.CYAN + "=" * 60)
    print(f"Configuration du problème avec {nombres_variables_base} variables et {nb_equations} contraintes")
    print("=" * 60 + Style.RESET_ALL)
    
    tab_optimisation = [0] 
    
    print(Fore.GREEN + "\n[1] FONCTION OBJECTIF (maximisation)" + Style.RESET_ALL)
    print(f"veuillez remplir la fonction optimisation : Max Z = {" + ".join([f"{chr(945 +i)}x{chr(0x2081+i)}" for i in range(nombres_variables_base)])}")

    for i in range(nombres_variables_base):
        while True:
            try:
                coeff = float(input(f"ecart_{chr(945+i)} : {Fore.YELLOW}"))
                print(Style.RESET_ALL, end="")
                tab_optimisation.append(coeff)
                break
            except ValueError:
                print(Fore.RED + "Veuillez entrer un nombre valide." + Style.RESET_ALL)
    
    equations = {}
    
    print(Fore.GREEN + "\n[2] CONTRAINTES" + Style.RESET_ALL)
    
    data_table = []
    header = ["Contrainte"] + [f"x{chr(0x2081+i)}" for i in range(nombres_variables_base)] + ["b"]
    
    for j in range(nb_equations):
        print(f"\nveuillez completer l'equation {j+1} :{" + ".join([f"{chr(945 +i)}{chr(0x2081+j)}x{chr(0x2081+i)}" for i in range(nombres_variables_base)])}{chr(62)}b{chr(0x2081+j)}")
        
        key_eq = "equation_"+str(j+1)
        equations[key_eq] = []
        
        while True:
            try:
                b_value = float(input(f"b{chr(0x2081+j)} = {Fore.YELLOW}"))
                print(Style.RESET_ALL, end="")
                equations[key_eq].append(b_value)
                break
            except ValueError:
                print(Fore.RED + "Veuillez entrer un nombre valide." + Style.RESET_ALL)
        
        coeffs = []
        for k in range(nombres_variables_base):
            while True:
                try:
                    coeff = float(input(f"{chr(945 +k)}{chr(0x2081+j)} = {Fore.YELLOW}"))
                    print(Style.RESET_ALL, end="")
                    coeffs.append(coeff)
                    equations[key_eq].append(coeff)
                    break
                except ValueError:
                    print(Fore.RED + "Veuillez entrer un nombre valide." + Style.RESET_ALL)
        
        data_table.append([f"Contrainte {j+1}"] + coeffs + [b_value])
    
    obj_row = ["Fonction objectif"] + tab_optimisation[1:] + [tab_optimisation[0]]
    
    print(Fore.CYAN + "\n" + "=" * 60)
    print("RÉCAPITULATIF DU PROBLÈME")
    print("=" * 60 + Style.RESET_ALL)
    
    print("\n" + tabulate([obj_row] + data_table, headers=header, tablefmt="grid", floatfmt=".2f"))
    
    variables = {
        "tab_optimisation": tab_optimisation,
        "nombres_variables_base": nombres_variables_base,
        "equations": equations,
        "nb_equations": nb_equations
    }
    
    return variables

def display_simplex_tableau(variables, iteration=0):
    """
    Fonction pour afficher le tableau du simplexe de manière esthétique.
    """
    equations = variables["equations"]
    tab_optimisation = variables["tab_optimisation"]
    
    print(Fore.CYAN + "\n" + "=" * 60)
    print(f"TABLEAU DU SIMPLEXE - ITÉRATION {iteration}")
    print("=" * 60 + Style.RESET_ALL)
    
    nb_vars = variables["nombres_variables_base"]
    nb_slack = variables["nb_equations"]
    
    headers = ["Base", "Cst"] + [f"x{chr(0x2081+i)}" for i in range(nb_vars)] + [f"s{chr(0x2081+i)}" for i in range(nb_slack)]
    
    rows = []
    
    obj_row = ["Z"] + tab_optimisation
    rows.append(obj_row)
    
    for i, (key, eq) in enumerate(equations.items()):
        base_var = f"s{chr(0x2081+i)}"  # Par défaut, variable d'écart
        rows.append([base_var] + eq)
    
    print(tabulate(rows, headers=headers, tablefmt="grid", floatfmt=".3f"))

def update_simplex_display(simplex_obj):
    """
    Fonction à utiliser pendant l'exécution de l'algorithme du simplexe
    pour mettre à jour l'affichage à chaque itération.
    """
    iteration = simplex_obj.current_iteration
    display_simplex_tableau(simplex_obj.variables, iteration)

if __name__ == "__main__":
    print(Fore.MAGENTA + "MÉTHODE DU SIMPLEXE - INTERFACE DE SAISIE" + Style.RESET_ALL)
    
    while True:
        try:
            nombres_variables_base = int(input("\nNombre de variables de décision : "))
            if nombres_variables_base <= 0:
                print(Fore.RED + "Le nombre doit être positif." + Style.RESET_ALL)
                continue
            break
        except ValueError:
            print(Fore.RED + "Veuillez entrer un nombre entier." + Style.RESET_ALL)
    
    while True:
        try:
            nb_equations = int(input("Nombre de contraintes : "))
            if nb_equations <= 0:
                print(Fore.RED + "Le nombre doit être positif." + Style.RESET_ALL)
                continue
            break
        except ValueError:
            print(Fore.RED + "Veuillez entrer un nombre entier." + Style.RESET_ALL)
    
    variables = tab_var(nombres_variables_base, nb_equations)
    
    display_simplex_tableau(variables)
// END OF FILE: variables.py

